/* SILK source code.  Copyright 2007-2009 W. Maddison and M. Ramirez.   Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code.  The commenting leaves much to be desired. Please approach this source code with the spirit of helping out. Perhaps with your help we can be more than a few, and make Mesquite better. Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY. Mesquite's web site is http://mesquiteproject.org This source code and its compiled class files are free and modifiable under the terms of  GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.silk.IndexedCharOntologyTerms; import java.util.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.silk.lib.*;/** ======================================================================== */public class IndexedCharOntologyTerms extends CharOntologySource implements IndexListener {	String indexDirectory = null;	String imageDirectoryBase = null; 	CharacterData data = null;	String relativeDirectory = "";	ImageIndexManager indexManager;	String urlPrefix, urlSuffix;		OntologyTerm[] ontologyTerms; //ontology terms for characters, in local numbering	String[] indexedCharacterUniqueIDs; //use this to find local character number	int[][] localCharNumToOntologyNum; //use this to find ontology terms for local character numbers	boolean ontologyAvailable = false;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		indexManager =(ImageIndexManager)findNearestColleagueWithDuty(ImageIndexManager.class);		if (!MesquiteThread.isScripting()){			loadIndices();		}		loadPreferences();		if (indexManager != null)			indexManager.addListener(this);		return true;	}	public void endJob(){		try{			if (this.data != null){				this.data.removeListener(this);				data.getTaxa().removeListener(this);			}			indexManager.removeListener(this);		}		catch (Exception e){		}		super.endJob();	}	public boolean ontologyAvailable(){		return ontologyAvailable;	}	public void indexChanged(){		indexDirectory = null;		imageDirectoryBase = null;		loadIndices();	}	public void imagesChanged(){		imageDirectoryBase = indexManager.getImageRootPath();		parametersChanged();	}	public void setData(CharacterData data){		this.data = data;	}	public CharacterData getData(){		return data;	}	public boolean loadIndices(){		if (indexDirectory == null){			indexDirectory = indexManager.getIndexDirectory();			relativeDirectory = MesquiteFile.decomposePath(getProject().getHomeFile().getDirectoryName(), indexDirectory);		}		if (imageDirectoryBase == null)			imageDirectoryBase = indexManager.getImageRootPath();		if (StringUtil.blank(indexDirectory))			return false;		logln("\nLoading ontology index files from " + indexDirectory + "\n");		MesquiteWindow.tickClock("Looking for OBO index");		String[] oboFile = loadFileLines("characters.obo");		if (oboFile == null)			return false;		processOBOTable(oboFile);		MesquiteWindow.tickClock("Loading ontology index");		log("Loading ontology index... ");		String[][] charsToOntologyTerms = loadFileTable("CharsToOntologyTerms.txt");		processCOTable(charsToOntologyTerms);		ontologyAvailable = (oboFile != null && charsToOntologyTerms != null && (ontologyTerms != null));		String[] urlLines = loadFileLines("OntologyWebSettings.txt");		processURL(urlLines);		return true;	}	public String getOntologyURL(String termID){		if (urlPrefix == null)			return null;		String url = urlPrefix + termID;		if (urlSuffix != null)			url += urlSuffix;		return url;	}	/*_________________________________________________*/	void processURL(String[] urlLines){		if (urlLines == null)			return;		StringBuffer sb = new StringBuffer();  //will record list of ontology terms		OntologyTerm ot = null;		int i = 0;		while (i<urlLines.length){			String line = urlLines[i];			String[] tokens = getTokens(urlLines[i], sb);			if (tokens != null && tokens.length >= 2){				if (tokens[0] != null && tokens[1] != null){					if (tokens[0].equalsIgnoreCase("OBOPathPrefix"))						urlPrefix = tokens[1];					else if (tokens[0].equalsIgnoreCase("OBOPathSuffix"))						urlSuffix = tokens[1];				}			}			i++;		}	}	/*-----------------------------------------------------------*/	/*_________________________________________________*/	void processOBOTable(String[] obo){		if (obo == null)			return;		Vector terms = new Vector();  //will record list of ontology terms		OntologyTerm ot = null;		int i = 0;		while (i<obo.length){			String line = obo[i];			if (line.startsWith("id:")){				String id = StringUtil.getAllAfterSubString(line, "id:");				id = StringUtil.stripLeadingWhitespace(id);				ot = new OntologyTerm();				terms.addElement(ot);				ot.id = id;			}			else if (ot != null){				if (line.startsWith("name:")){					String name = StringUtil.getAllAfterSubString(line, "name:");					name = StringUtil.stripLeadingWhitespace(name);					ot.name = name;				}				else if (line.startsWith("comment:")){					String comment = StringUtil.getAllAfterSubString(line, "comment:");					comment = StringUtil.stripLeadingWhitespace(comment);					ot.comment = comment;				}				else if (line.startsWith("def:")){					String def = StringUtil.getAllAfterSubString(line, "def:");					def = StringUtil.stripLeadingWhitespace(def);					ot.def = def;				}				else if (line.startsWith("[Term]")){					ot = null;				}			}			i++;		}		ontologyTerms = new OntologyTerm[terms.size()];		for (int k=0; k<terms.size(); k++){			ontologyTerms[k] = (OntologyTerm)terms.elementAt(k);		}	}	int whichOntologyTerm(String otID){		for (int i=0; i<ontologyTerms.length; i++){			if (ontologyTerms[i] != null && otID != null && otID.equals(ontologyTerms[i].id))				return i;		}		return -1;	}	/*_________________________________________________*/	void processCOTable(String[][] cToOTs){		int OTcolumn = 1;		int CharIDcolumn = 0;		//String[] indexedCharacterUniqueIDs; //use this to find local character number		//now use the following to find standard views that correspond		//int[][] standardViewsForIndexedChars; //each row is a list of standard views for a character (chars numbered locally)		//String[] standardViewNames		Vector characterIDs = new Vector();  //will record char id's in order received		Vector otNumbers = new Vector();  //same order as previous; will record list of numbers of ontology terms		for (int i= 1; i< cToOTs.length; i++){			String charID = cToOTs[i][CharIDcolumn];			String otID = cToOTs[i][OTcolumn];			int localCharNumber = StringArray.indexOf(characterIDs, charID);  //finding local char number from id			if (localCharNumber<0){				characterIDs.addElement(charID);				int whichTerm = whichOntologyTerm(otID);				otNumbers.addElement(new int[]{whichTerm});			}			else {				int[] soFar = (int[])otNumbers.elementAt(localCharNumber);				otNumbers.removeElementAt(localCharNumber);				int[] augmented = IntegerArray.addParts(soFar, soFar.length, 1);				augmented[augmented.length-1] =  whichOntologyTerm(otID);				otNumbers.insertElementAt(augmented, localCharNumber);			}		}		indexedCharacterUniqueIDs = new String[characterIDs.size()];		for (int i=0; i<characterIDs.size(); i++){			indexedCharacterUniqueIDs[i] = (String)characterIDs.elementAt(i);		}		localCharNumToOntologyNum = new int[otNumbers.size()][];		for (int i=0; i<otNumbers.size(); i++){			localCharNumToOntologyNum[i] = ((int[])otNumbers.elementAt(i));		}	}	/*_________________________________________________*/	public OntologyTerm[] getOntologyTerms(CharacterData data, int ic){		if (!ontologyAvailable())			return null;		String uid = data.getUniqueID(ic);		int localCharacterNumber = StringArray.indexOf(indexedCharacterUniqueIDs, uid);  //finding local taxon number from id		if (localCharacterNumber>=0){			int[] ontologyNumbers = localCharNumToOntologyNum[localCharacterNumber];			if (ontologyNumbers != null){				OntologyTerm[] terms = new OntologyTerm[ontologyNumbers.length];				for (int i=0; i< terms.length; i++)					terms[i] = ontologyTerms[ontologyNumbers[i]];				return terms;			}		}		return null;	}	String pathSeparator(String before){		if (indexManager== null) {			if (before == null || !before.endsWith("/"))				return "/";		}		else if (indexManager.useLocalImages()) {			if (before == null || !before.endsWith(MesquiteFile.fileSeparator))				return MesquiteFile.fileSeparator;		}		else {			if (before == null || !before.endsWith("/"))				return "/";		}		return "";	}	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine("load");		return temp;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Loads indices", null, commandName, "load")) {			loadIndices();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*-----------------------------------------------------------*/	String prepareLine(String line, StringBuffer sb){		if (line.indexOf("\t\t")>=0){			sb.setLength(0);			sb.append(line);			boolean prev = false;			for (int i=sb.length()-1; i>=0; i--){				if (sb.charAt(i) == '\t'){					if (prev){						sb.insert(i+1, ' ');					}					prev = true;				}				else					prev = false;			}			return sb.toString();		}		return line;	}	/*-----------------------------------------------------------*/	String[] getTokens(String line, StringBuffer sb){		String[] result;		line = prepareLine(line, sb);		StringTokenizer t = new StringTokenizer(line, "\t");		String tok = null;		int count = t.countTokens();		/*try{			while ((tok = t.nextToken())!= null) {				count++;			}		}		catch (NoSuchElementException e){		}*/		result = new String[count];		//	StringTokenizer t2 = new StringTokenizer(line, "\t");		tok = null;		count = 0;		try{			while (t.hasMoreTokens()){				tok = t.nextToken();				if (tok == null)					tok = "";				result[count] = tok;				count++;			}		}		catch (NoSuchElementException e){		}		return result;	}	/*-----------------------------------------------------------*/	public String[][] loadFileTable(String fileName){		String[] lines = null;		if (indexDirectory.indexOf("://")>=0){			lines = MesquiteFile.getURLContentsAsStrings(indexDirectory + "/" + fileName);		}		else {			lines = MesquiteFile.getFileContentsAsStrings(indexDirectory + MesquiteFile.fileSeparator + fileName);		}		if (lines == null)			return null;		String[][] result = new String[lines.length][];		StringBuffer sb = new StringBuffer();		for (int i= 0; i<lines.length; i++) {			result[i] = getTokens(lines[i], sb);			lines[i] = null;			if (i % 1000 == 0)				log(".");		}		if (result != null && result.length>0){			String s = " ";			for (int i= 0; i<result[0].length; i++) {				s += result[0][i] + " ";			}			//	logln("File read with headings " + s);		}		return result;	}	/*-----------------------------------------------------------*/	public String[] loadFileLines(String fileName){		String[] lines = null;		if (indexDirectory.indexOf("://")>=0){			lines = MesquiteFile.getURLContentsAsStrings(indexDirectory + "/" + fileName);		}		else {			if (MesquiteFile.fileExists(indexDirectory + MesquiteFile.fileSeparator + fileName)){				log("Loading OBO file .. ");				lines = MesquiteFile.getFileContentsAsStrings(indexDirectory + MesquiteFile.fileSeparator + fileName);			}		}		/*for (int i=0; i<lines.length; i++)			if (lines[i] != null)				lines[i] = StringUtil.stripLeadingWhitespace(lines[i]);		 */		return lines;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	public String getName() {		return "Character Ontology Terms";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Gives ontology term information from indexed storage." ;	}}