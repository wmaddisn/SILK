/* SILK source code.  Copyright 2007-2009 W. Maddison and M. Ramirez.   Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code.  The commenting leaves much to be desired. Please approach this source code with the spirit of helping out. Perhaps with your help we can be more than a few, and make Mesquite better. Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY. Mesquite's web site is http://mesquiteproject.org This source code and its compiled class files are free and modifiable under the terms of  GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.silk.StateImages;import java.util.*;import java.awt.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.categ.lib.*;import mesquite.lib.duties.*;import mesquite.lib.misc.AttachedNotesVector;import mesquite.lib.table.*;import mesquite.lib.taxa.Taxa;import mesquite.lib.ui.ColorDistribution;import mesquite.lib.ui.ColorRecord;import mesquite.lib.ui.MesquiteMenuItemSpec;import mesquite.lib.ui.MesquiteMenuSpec;import mesquite.lib.ui.MesquiteTool;import mesquite.lib.ui.MesquiteWindow;import mesquite.lib.ui.StringInABox;import mesquite.silk.lib.*;/** ======================================================================== */public class StateImages extends DataWindowAssistantI implements CellColorer, CellColorerCharacters, CellColorerMatrix, PanelOwner {	public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed		EmployeeNeed e2 = registerEmployeeNeed(CharStateImageSource.class, "A state images source supplies images for display of state images in a character matrix editor.",		"This is activated when you choose Show States Info Panel from the Matrix menu of a Character Matrix Editor");	}	CharacterData data;	Taxa taxa;	StateDWPanel panel;	StateDWImagePanel iPanel;	MesquiteBoolean showPanel;	MesquiteBoolean showCharAnnotations;	MesquiteBoolean showStateAnnotations;	MesquiteBoolean showLocations;	CharStateImageSource imageSource = null;	MesquiteTable table;	MesquiteMenuSpec menu;	MesquiteMenuItemSpec sami, scmi, slmi;	int[] cache;	/* ................................................................................................................. */	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		showPanel = new MesquiteBoolean(false);		showCharAnnotations = new MesquiteBoolean(false);		showStateAnnotations = new MesquiteBoolean(false);		showLocations = new MesquiteBoolean(false);		getEmployer().addCheckMenuItem(null, "Show States Info Panel", makeCommand("togglePanel", this), showPanel);		return true;	}	/* ................................................................................................................. */	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine("togglePanel " + showPanel.toOffOnString());		if (!showPanel.getValue())			temp.suppressCommandsToEmployee(imageSource);		temp.addLine("toggleStateAnnotations " + showStateAnnotations.toOffOnString());		temp.addLine("toggleCharAnnotations " + showCharAnnotations.toOffOnString());		temp.addLine("toggleLocations " + showLocations.toOffOnString());		// todo here: set source of images, and split as separate command below		return temp;	}	/* ................................................................................................................. */	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Sets whether or not the states panel is shown", "[on = shown; off]", commandName, "togglePanel")) {			showPanel.toggleValue(parser.getFirstToken(arguments));			if (showPanel.getValue() && imageSource == null) {				imageSource = (CharStateImageSource) hireEmployee(CharStateImageSource.class, "Source of images");				if (imageSource == null)					showPanel.setValue(false);				else					imageSource.setData(data);			}			setPanel();		}		else if (checker.compare(this.getClass(), "Reassures module no source is used yet", null, commandName, "noSource")) {		}		else if (checker.compare(this.getClass(), "here for backward compatibility", null, commandName, "showColors")) {		}		else if (checker.compare(this.getClass(), "Sets whether or not the character annotations are shown", "[on = shown; off]", commandName, "toggleCharAnnotations")) {			showCharAnnotations.toggleValue(parser.getFirstToken(arguments));			if (iPanel != null)				iPanel.reset();		}		else if (checker.compare(this.getClass(), "Sets whether or not the state annotations are shown", "[on = shown; off]", commandName, "toggleStateAnnotations")) {			showStateAnnotations.toggleValue(parser.getFirstToken(arguments));			if (iPanel != null)				iPanel.reset();			if (panel != null)				panel.setCell(previousChar, true);		}		else if (checker.compare(this.getClass(), "Sets whether or not the image locations are shown", "[on = shown; off]", commandName, "toggleLocations")) {			showLocations.toggleValue(parser.getFirstToken(arguments));			if (iPanel != null){				iPanel.reset();				iPanel.showLocation.setValue(showLocations.getValue());			}			if (panel != null)				panel.setCell(previousChar, true);		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/* ................................................................................................................. */	public boolean isSubstantive() {		return false;	}	public void viewChanged() {	}	public void endJob(){		super.endJob();		if (data != null)			data.removeListener(this);	}	public void setTableAndData(MesquiteTable table, CharacterData data) {		this.table = table;		if (this.data != data){			if (this.data != null)				this.data.removeListener(this);			if (data != null)				data.addListener(this);		}		this.data = data;		if (data != null)			taxa = data.getTaxa();		setPanel();	}	/* ................................................................................................................. */	void setPanel() {		MesquiteWindow f = containerOfModule();		if (f instanceof TableWindow) {			if (showPanel.getValue()) {				if (panel == null) {					panel = new StateDWPanel(this);				}				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker){					if (!MesquiteThread.isScripting()){						((DataWindowMaker)mb).demandCellColorer(this, 0, 0, null);						((DataWindowMaker)mb).demandCellColorer(this, 0, -1, null);					}									}				((TableWindow) f).addSidePanel(panel, DWPanel.width);				iPanel = (StateDWImagePanel) panel.getPanel();				iPanel.setData(data);				iPanel.setImageSource(imageSource);				if (menu == null){					menu = makeMenu("State_Info");					sami = addCheckMenuItem(null, "Show State Annotations", makeCommand("toggleStateAnnotations", this), showStateAnnotations);					scmi = addCheckMenuItem(null, "Show Character Annotations", makeCommand("toggleCharAnnotations", this), showCharAnnotations);					slmi = addCheckMenuItem(null, "Show Image Locations", makeCommand("toggleLocations", this), showLocations);					resetContainingMenuBar();				}				focusInCell(previousChar, previousTax);			}			else {				if (panel != null)					((TableWindow) f).removeSidePanel(panel);				MesquiteModule mb = findEmployerWithDuty(DataWindowMaker.class);				if (mb != null && mb instanceof DataWindowMaker)					((DataWindowMaker)mb).resignCellColorer(this);				if (menu != null){					destroyMenu();					deleteMenuItem(sami);					deleteMenuItem(scmi);					deleteMenuItem(slmi);					resetContainingMenuBar();				}				menu = null;			}		}	}	/* ................................................................................................................. */	public boolean hasDisplayModifications() {		return false;	}	public void panelGoAway(Panel p) {		showPanel.setValue(false);		setPanel();	}	public void panelIncreaseDecrease(boolean increase) {		if (iPanel != null)			iPanel.fontSizeChange(increase);	}	public void employeeParametersChanged(MesquiteModule employee, MesquiteModule source, Notification notification) {		if (employee == imageSource) {			cache = null;			if (notification != null && notification.getCode() == CharStateImageSource.IMAGESREADY && iPanel != null){				iPanel.setReady(true);				iPanel.repaint("Ready to display images");			}			else if (notification != null && notification.getCode() == CharStateImageSource.IMAGESNOTREADY && iPanel != null){				iPanel.setReady(false);				iPanel.repaint(imageSource.waitingMessage());				return;			}			else if (iPanel != null)				iPanel.repaint("");			if (table != null)				table.repaintAll();			parametersChanged();			focusInCell(previousChar, previousTax);		}	}	int previousChar = -1;	String previousCharID = null;	int previousTax = -1;	/* ................................................................................................................. */	public void focusInCell(int ic, int it) {		if (data == null || iPanel == null)			return;		if (panel == null || imageSource == null)			return;		if (data.anySelected())			return;		previousChar = ic;		previousCharID = data.getUniqueID(ic);		previousTax = it;		if (showPanel.getValue())			panel.setCell(ic, false);		}	/* ................................................................................................................. */	public String getName() {		return "Character State Images";	}	/* ................................................................................................................. */	public String getNameForMenuItem() {		return "*States Typified?";	}	/* ................................................................................................................. */	public String getVersion() {		return null;	}	/* ................................................................................................................. */	public String getExplanation() {		return "Installs a panel with images of states for a character matrix (part of the SILK package).";	}	/*.................................................................................................................*/	public boolean setActiveColors(boolean active){		if (!MesquiteThread.isScripting() && active && !showPanel.getValue()){			discreetAlert( "Sorry, can't color by state typification if the States Info Panel is not turned on");			return false;		}		setActive(active);		return true; 	}	public String getColorsExplanation(){		return null;	}	/*.................................................................................................................*/	/** passes which object changed, along with optional integer (e.g. for character) (from MesquiteListener interface)*/	public void changed(Object caller, Object obj, Notification notification){		int code = Notification.getCode(notification);		int[] parameters = Notification.getParameters(notification);		if (obj instanceof CharacterData && (CharacterData)obj ==data && panel != null) {			if (code==MesquiteListener.DATA_CHANGED) {			}			else if (code==MesquiteListener.SELECTION_CHANGED ) {				if (data.numberSelected()>1){					panel.setCell(-3, false);				}				else if (data.anySelected()){  //exactly one selected; set it					panel.setCell(data.firstSelected(), true);				}				else					panel.setCell(-3, true);							}			else if (code==MesquiteListener.PARTS_DELETED || code==MesquiteListener.PARTS_ADDED || code==MesquiteListener.PARTS_MOVED) {					if (previousCharID != null){						int ic = data.findByUniqueID(previousCharID);						if (ic >=0 && ic < data.getNumChars() && ic != previousChar)							panel.setCell(ic, true);												}			}			else if (code==MesquiteListener.NAMES_CHANGED) {				panel.setCell(previousChar, true);			}		}				super.changed(caller, obj, notification);	}	private int getTypificationStatus(int ic){		try{			if (ic<0)				return 0;			if (cache == null || cache.length != data.getNumChars()){				cache = new int[data.getNumChars()];				for (int ic2 = 0; ic2<data.getNumChars(); ic2++)					cache[ic2]= -1;			}			if (cache[ic] < 0){				boolean anyInDatabase = false;				int[] nums = imageSource.getNumCharacterStateImages(data, ic);				if (nums != null){					for (int i=0; i<nums.length; i++)						if (nums[i]>0)							anyInDatabase = true;				}				boolean anyInAnnotations = false;				int maxState = ((CategoricalData)data).maxStateWithDefinition(ic);				for (int state = 0; state < maxState && !anyInAnnotations; state++){					AttachedNotesVector v = ((CategoricalData)data).getStateAnnotationsVector(ic, state);					if (v != null)						for (int k = 0; k< v.getNumNotes() && !anyInAnnotations; k++){							AttachedNote note = v.getAttachedNote(k);							if (!StringUtil.blank(note.getImagePath()))								anyInAnnotations = true;						}				}				if (anyInAnnotations){					if (anyInDatabase)						cache[ic] = 3;					else						cache[ic] = 1;				}				else if (anyInDatabase)					cache[ic] = 2;				else					cache[ic] = 0;			}			return cache[ic];		}		catch (Exception e){			MesquiteFile.throwableToLog(this, e);		}		return 0;	}	public Color getCellColor(int ic, int it){		if (data == null || imageSource == null)			return null;		int num = getTypificationStatus(ic);		if (num <= 0)			return Color.white;		if (num== 1)			return ColorDistribution.lightBlue;		if (num== 2)			return Color.green;		return Color.cyan;	}	public String getCellString(int ic, int it){		if (data == null || imageSource == null || ic<0)			return null;		int num = getTypificationStatus(ic);		if (num == 0)			return "No images in State Annotations or in Database for states of this character";		if (num == 1)			return "Images in State Annotations for states of this character";		if (num == 2)			return "Images in Database for states of this character";		return "Images in both State Annotations or in Database for states of this character";	}	ColorRecord[] legend;	public ColorRecord[] getLegendColors(){		if (legend == null) {			legend = new ColorRecord[4];			legend[0] = new ColorRecord(Color.white, "No Images");			legend[1] = new ColorRecord(ColorDistribution.lightBlue, "Images in State Annotations, but not in Database");			legend[2] = new ColorRecord(Color.green, "Images in Database, but not in State Annotations");			legend[3] = new ColorRecord(Color.cyan, "Images in both State Annotations and in Database");		}		return legend;	}	public void colorsLegendGoAway(){  	}}class StateDWPanel extends DWPanel {	int ic = -1;	StateImages module;	public StateDWPanel(StateImages pw) {		super(pw, true);		this.module = pw;		setFont(new Font("Arial", Font.PLAIN, 12));		setBackground(Color.gray);		setForeground(Color.white);	}	public DWImagePanel makePanel() {		return new StateDWImagePanel((StateImages)pw);	}	public String getTitleString() {		if (ic < 0)			return "State information";		return "States of Character " + (ic + 1);	}	/**/	void setCell(int ic, boolean resetRegardless) {		if (!resetRegardless && ic == this.ic) {			return;		}		int[] numImages = module.imageSource.getNumCharacterStateImages(module.data, ic);		if (numImages == null)			return;		this.ic = ic;		this.numImagesVertical = numImages.length;		// scroll.setMaximumValue(numImages-1);		((StateDWImagePanel) getPanel()).showImages(ic, numImages);		repaint();		getPanel().repaint();	}}class StateDWImagePanel extends DWImagePanel  {	CharStateImageSource source;	int[] indexedImageIndex;	CategoricalData data;	CharAnotImagePanel anotPanel;	int currentIC = 0;	int noteImagesHeight = 32;	boolean charNotesShown = false;	boolean stateNotesShown = false;	StateImages module;	boolean ready = false;	public StateDWImagePanel(StateImages module) {		super(true);		this.module = module;		setBackground(Color.white);		warnIfNoImage = true;		topBuffer = 4;		anotPanel = new CharAnotImagePanel(this);		setLayout(null);		//	setBackground(Color.green);		add(anotPanel);		anotPanel.setBounds(0, getBounds().height - noteImagesHeight, getBounds().width, noteImagesHeight);		anotPanel.setVisible(charNotesShown);	}	public void fontSizeChange(boolean increase){		super.fontSizeChange(increase);		anotPanel.fontSizeChange(increase);	}	public void blank(Graphics g, String s){		if (!ready){			g.setColor(Color.gray);			g.fillRect(0, 0, getBounds().width, getBounds().height);			g.setColor(Color.white);			if (s != null)				g.drawString(s, 10, 50);			g.setColor(Color.black);		}		else {			g.setColor(Color.white);			g.fillRect(0, 0, getBounds().width, getBounds().height);			g.setColor(Color.blue);			if (s != null)				g.drawString(s, 10, 50);			g.setColor(Color.black);		}	}	public void setReady(boolean ready){		this.ready = ready;	}	public int getMainSectionHeight(){		if (charNotesShown)			return getBounds().height - noteImagesHeight;		else			return getBounds().height;	}	public void setData(CharacterData data) {		if (!(data instanceof CategoricalData)){			return;		}		this.data = (CategoricalData)data;		anotPanel.setData(data);	}	public void reset(){		charNotesShown = module.showCharAnnotations.getValue();		anotPanel.setVisible(charNotesShown);		stateNotesShown = module.showStateAnnotations.getValue();		repaint();	}	public void setImageSource(CharStateImageSource source) {		this.source = source;	}	int[] numImagesArray;	public void showImages(int ic,  int[] numImagesArray){		stopCurrentPreparations();		currentIC = ic;		this.numImagesArray = numImagesArray;		prepareImages();	}	public void loadInformation(){		//	try {		if (stop)			return;		int ic = currentIC;		anotPanel.setCell(ic, -1);		//	Image rule = MesquiteImage.getImage(MesquiteTrunk.getRootImageDirectoryPath() + "hr.gif");		int numImages = 0;		if (numImagesArray != null){			for (int i=0; i<numImagesArray.length; i++)				numImages+= numImagesArray[i];  //+1 for state name		}		if (stop)			return;		//finding number of states to consider; each one will receive a line for a name; also footnotes, and annotations vector		int maxState = Math.max(data.getMaxState(ic), data.maxStateWithName(ic));		int mswi = source.getMaxStateWithImages(data, ic);		if (mswi>maxState)			maxState = mswi;		if (stateNotesShown)			for (int i = 0; i< CategoricalState.getMaxPossibleStateStatic(); i++){				if (stop)					return;				AttachedNotesVector v = ((CategoricalData)data).getStateAnnotationsVector(ic, i);				if (v != null){					numImages+= v.getNumNotes();					if (i> maxState)						maxState = i;				}				if (!StringUtil.blank(((CategoricalData)data).getStateNote(ic, i))){					numImages++;					if (i> maxState)						maxState = i;				}			}		if (numImages == 0 && data.maxStateWithName(ic) <0){			prepareMemory(1);			comments[0] = new StringInABox("Nothing to show", fontBOLD, getBounds().width - 8);			specialCase[0] = NoColumn;			suppressImageWarning[0]= true;			return;		}		String charComment = source.getCharacterComment(data, ic);		if (charComment != null)			numImages++;		numImages += (maxState +1)*2 +1 - 1; //each char gets a title and a bar, and there is the character line, but no line on last state plus one for comment		if (stop)			return;		prepareMemory(numImages);		if (stop)			return;		indexedImageIndex = new int[numImages];		for (int i=0; i<numImages; i++)			indexedImageIndex[i] = -1;		currentIC = ic;		int counter = 0;		//first, the character name		String charS = "Character";		if (data.characterHasName(currentIC))			charS += ": " + data.getCharacterName(currentIC);		else			charS += Integer.toString(ic+1);		comments[counter] = new StringInABox(charS, fontBOLD, getBounds().width - 8);		charS = data.getAnnotation(ic);		if (charS == null)			charS = "";		if (charComment != null) {			if (!StringUtil.blank(charS))				charS += "\n";			charS += charComment;		}		if (!StringUtil.blank(charS))			explanations[counter] =  new StringInABox(charS, font, getBounds().width - 8);		specialCase[counter] = NoColumnLineAfter;		suppressImageWarning[counter]= true;		counter++;		int imageCounter = 0;		for (int i = 0; i <= maxState; i++) {			if (stop)				return;			//first, the state name & footnote			String stateName = "";			if (counter >= comments.length)				MesquiteMessage.printStackTrace("out of bounds array in state images " + counter + "  " + comments.length);			if (data instanceof CategoricalData && !StringUtil.blank(((CategoricalData)data).getStateName(ic, i)))				stateName = " (" + ((CategoricalData)data).getStateName(ic, i) + ")";			comments[counter] = new StringInABox("State " + i + stateName, fontBIGBOLD, getBounds().width - 8);			if (!StringUtil.blank(((CategoricalData)data).getStateNote(ic, i))) {				explanations[counter] = new StringInABox("footnote: " + ((CategoricalData)data).getStateNote(ic, i), font, getBounds().width - 8);			}			specialCase[counter] = NoColumn;			suppressImageWarning[counter]= true;			counter++;			//next, the indexed images			Vector comment = new Vector();			Vector location = new Vector();			int addVertBar = -1;			MesquiteWindow.tickClock("Loading images for state " + (i));			Image[] stateImages = source.getCharacterStateImages(i, data, ic, comment, location);			if (stateImages != null){				for (int im = 0; im < stateImages.length && counter < images.length; im++) {					if (stop)						return;					origImageNumbers[counter] = imageCounter;					imageCounter++;					images[counter] = stateImages[im];					indexedImageIndex[counter] = i;					comments[counter] = new StringInABox(comment.elementAt(im).toString(), font, getBounds().width - 8);					comments[counter].setFont(fontBOLD);					locations[counter] = new StringInABox("" + location.elementAt(im), font, getBounds().width - 8);					counter++;				}				addVertBar = counter-1;				//	if (stateNotesShown)				//		marker[counter] = "Annotations";			}			if (stateNotesShown){				//now, the attached notes				AttachedNotesVector v = ((CategoricalData)data).getStateAnnotationsVector(ic, i);				if (v != null)					for (int k = 0; k< v.getNumNotes(); k++){						if (stop)							return;						if (addVertBar>=0) {							//	marker[counter] = "Annotations";//							specialCase[addVertBar] = NoColumnLineAfterPale;							suppressImageWarning[addVertBar]= true;						//	counter++;						}						addVertBar = -1;						AttachedNote note = v.getAttachedNote(k);						images[counter] = note.getImage();						suppressImageWarning[counter]= true;						comments[counter] = new StringInABox(note.getComment(), font, getBounds().width - 8);						explanations[counter] = new StringInABox("(" + note.getAuthorName() + ")", font, getBounds().width - 8);						explanations[counter].setFont(fontBOLD);						counter++;						//				locations[counter] = new StringInABox("" + location.elementAt(im), font, getBounds().width - 8);					}			}			addVertBar = -1;			//		images[counter] = rule;			//if (i != maxState){			MesquiteWindow.hideClock();			try {				if (counter<numImages && i != maxState){					suppressImageWarning[counter]= true;					specialCase[counter] = NoColumnLineAfter;				}			}			catch (Exception e){				MesquiteFile.throwableToLog(this, e);			}			counter++;			///AttachedNotesVector getStateAnnotationsVector(int ic, int state)			if (stop)				return;		}		for (int i = counter-1; i<numImages; i++)			suppressImageWarning[i]= true;		/**		}		catch (Exception e){		}		/**/	}	/*	 public void paint(Graphics g){		super.paint(g);		if (currentIC >= 0 && data != null && currentIC < data.getNumChars() && data.characterHasName(currentIC)){			g.setFont(fontBOLD);			g.drawString("Character: " + data.getCharacterName(currentIC), 8, 20);		}	}	 */	public void mouseDown(int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		int im = findImage(x, y);		if (clickCount > 1 && source != null) {			//if (indexedImageIndex != null && im >=0 && im<indexedImageIndex.length && indexedImageIndex[im]>=0){			source.showCloseupCharImage(im, data, currentIC, modifiers);			//}		}	}	void requestSizeAnot(int change){		if (noteImagesHeight + change >8 && noteImagesHeight + change < getBounds().height - 16){			noteImagesHeight += change;			anotPanel.setBounds(0, getBounds().height - noteImagesHeight, getBounds().width, noteImagesHeight);			repaint();		}	}	public void setBounds(int x, int y, int width, int height){		super.setBounds(x, y, width, height);		anotPanel.setBounds(0, height - noteImagesHeight, width, noteImagesHeight);	}	public void setSize( int width, int height){		super.setSize(width, height);		anotPanel.setBounds(0, height - noteImagesHeight, width, noteImagesHeight);	}}/*======================================================*/class CharAnotImagePanel extends DWImagePanel implements MoverHolder{	int moverHeight = Mover.HEIGHT;	NameReference notesNameRef = NameReference.getNameReference("notes");	int currentIC = 0;	int currentIT = 0;	CharacterData data;	StateDWImagePanel parent;	Mover mover;	AttachedNotesVector notes;	public CharAnotImagePanel (StateDWImagePanel parent){		super(false);		verbose = true;		topBuffer = moverHeight;		setLayout(null);		mover = new Mover(this, "Character Annotations");		add(mover);		mover.setBounds(0, 0, getBounds().width, moverHeight); 		this.parent = parent;	}	public void setData(CharacterData data){		this.data = data;	}	public void setCell(int ic, int it){		if (ic < 0)			notes = null;		else			notes = (AttachedNotesVector)data.getAssociatedObject(notesNameRef, ic);		if (notes == null){			images = null;			comments = null;			locations = null;			repaint();			return;		}		int extra = 0;		prepareMemory(notes.getNumNotes());		//	comments[extra] = new StringInABox(data.getCharacterName(ic), fontBOLD, getBounds().width-8);		try{			for (int i=0; i< notes.getNumNotes(); i++){				AttachedNote note = notes.getAttachedNote(i);				images[i+extra] = note.getImage() ;				String c = note.getComment();				String a = note.getAuthorName();				String s = "";				if (!StringUtil.blank(c))					s = c;				if (!StringUtil.blank(a))					s += " (" + a + ")";				comments[i+extra] = new StringInABox(s, font, getBounds().width-8);				if (images[i+extra] == null) {					specialCase[i+extra] = NoColumnLineAfter;					if (i>0 && images[i-1+extra] != null)						specialCase[i-1+extra] = NoColumnLineAfter;				}			}		}		catch (Exception e){			MesquiteFile.throwableToLog(this,e);		}		repaint();	}	public void setBounds(int x, int y, int width, int height){		super.setBounds(x, y, width, height);		mover.setBounds(0, 0, getBounds().width, moverHeight); 	}	public void setSize( int width, int height){		super.setSize(width, height);		mover.setBounds(0, 0, getBounds().width, moverHeight); 	}	public void blank(Graphics g, String s){		g.setColor(Color.white);		g.fillRect(0, 0, getBounds().width, getBounds().height);		g.setColor(Color.blue);		if (s != null)			g.drawString(s, 10, 50);		g.setColor(Color.black);	}	public void requestVertChange(int change){		parent.requestSizeAnot(change);	}}