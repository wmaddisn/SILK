/* SILK source code.  Copyright 2007-2009 W. Maddison and M. Ramirez. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.silk.IndexedStateImages; import java.util.*;import java.awt.*;import java.io.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.ui.MesquiteImage;import mesquite.categ.lib.*;import mesquite.silk.lib.*;/** ======================================================================== */public class IndexedStateImages extends CharStateImageSource implements IndexListener {	String indexDirectory = null;	String imageDirectoryBase = null; 	String prefixLow = null;	String prefixHigh = null;	String relativeDirectory = "";	String[][] stateTypeImages;  	int CharStateImageTypification_CharID = -1;	int CharStateImageTypification_CharName = -1;	int CharStateImageTypification_CharComment = -1;	int CharStateImageTypification_State = -1;	int CharStateImageTypification_Comment = -1;	int CharStateImageTypification_ImageFileName = -1;	int CharStateImageTypification_RelativePath = -1;	CharacterData data = null;	ImageIndexManager indexManager;	/*	characterID state path comment	characterID state path comment	 */	boolean ready = false;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		indexManager =(ImageIndexManager)findNearestColleagueWithDuty(ImageIndexManager.class);		if (!MesquiteThread.isScripting()){			requestLoadIndices();		}		loadPreferences();		addMenuItem( "Search for Missing Images...", makeCommand("searchMissing",  this));		if (indexManager != null)			indexManager.addListener(this);		return true;	}	public void endJob(){		indexManager.removeListener(this);		super.endJob();	}	public void indexChanged(){		indexDirectory = null;		imageDirectoryBase = null;		prefixLow = null;		prefixHigh = null;		requestLoadIndices();	}	public void imagesChanged(){		imageDirectoryBase = indexManager.getImageRootPath();		prefixLow = null;		prefixHigh = null;		parametersChanged();	}	void requestLoadIndices(){		if (indexDirectory == null){			indexDirectory = indexManager.getIndexDirectory();			relativeDirectory = MesquiteFile.decomposePath(getProject().getHomeFile().getDirectoryName(), indexDirectory);		}		if (imageDirectoryBase == null)			imageDirectoryBase = indexManager.getImageRootPath();		logln("Request to load indices for images: " + indexDirectory);		if (StringUtil.blank(indexDirectory))			return;		indexManager.requestLoadIndices(this);	}	private void findColumnsCharStateImageTypification(String[][] table){		if (table == null || table.length == 0 || table[0].length == 0)			return;		for (int i=0; i< table[0].length; i++){			if (table[0][i] != null){				if (table[0][i].equalsIgnoreCase("CharID"))					CharStateImageTypification_CharID = i;				else if (table[0][i].equalsIgnoreCase("CharName"))					CharStateImageTypification_CharName = i;				else if (table[0][i].equalsIgnoreCase("CharComment"))					CharStateImageTypification_CharComment = i;				else if (table[0][i].equalsIgnoreCase("State"))					CharStateImageTypification_State = i;				else if (table[0][i].equalsIgnoreCase("Comment"))					CharStateImageTypification_Comment = i;				else if (table[0][i].equalsIgnoreCase("ImageFileName"))					CharStateImageTypification_ImageFileName = i;				else if (table[0][i].equalsIgnoreCase("RelativePath"))					CharStateImageTypification_RelativePath = i;			}		}	}	String notReadyMessage = "Reading Image Indices... ";	public boolean loadIndices(){		notReadyMessage = "Reading Image Indices... ";		parametersChanged(new Notification(IMAGESNOTREADY));		logln("Loading index files from " + indexDirectory);		stateTypeImages = loadFile("CharStateImageTypification.txt");		findColumnsCharStateImageTypification(stateTypeImages);		if (stateTypeImages != null)			logln("State type images index loaded");		else			logln("State type images index LOADING FAILED");		ready = (stateTypeImages != null);		if (ready) {			parametersChanged(new Notification(IMAGESREADY));		}		else {			notReadyMessage = "Indices failed to load; confirm Indexed Image Location.";			parametersChanged(new Notification(IMAGESNOTREADY));		}		return true;	}	public String waitingMessage(){		if (!ready) {			return notReadyMessage;		}		return null;	}	String pathSeparator(String before){		if (indexManager== null) {			if (before == null || !before.endsWith("/"))				return "/";		}		else if (indexManager.useLocalImages()) {			if (before == null || !before.endsWith(MesquiteFile.fileSeparator))				return MesquiteFile.fileSeparator;		}		else {			if (before == null || !before.endsWith("/"))				return "/";		}		return "";	}	public void setData(CharacterData data){		this.data = data;	}	public CharacterData getData(){		return data;	}	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine("load");		return temp;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Loads indices", null, commandName, "load")) {			requestLoadIndices();		}		else if (checker.compare(this.getClass(), "Search for missing images", null, commandName, "searchMissing")) {			if (indexDirectory == null)				requestLoadIndices();			scanImages();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	public void scanImages(){		if (data == null)			return;		/*		 * 	 int[] getNumCellImages(CharacterData data, int ic, int it){			 getCellImage(int i, CharacterData data, int ic, int it, MesquiteString comment, MesquiteString location){		}		 */		int countLocal =0;		int countRemote = 0;		int countMissing = 0;		for (int ic = 0; ic<data.getNumChars(); ic++){			String characterID = data.getUniqueID(ic);			String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";			if (prefixLow == null)				prefixLow = getPrefix(base);			for (int k = 0; k<= CategoricalState.maxCategoricalState; k++){				String[][] paths = getCharacterImages(characterID, k, prefixLow);				if (paths != null){					int numPaths = getNumberNonNull(paths);					for (int i=0; i<numPaths; i++){						String path = getNonNull(paths, i);						if (path != null){							if (path.indexOf("://")<0) {								countLocal++;								path = base + pathSeparator(base)  + path;								if (MesquiteFile.fileSeparator.equals("/"))									path = StringUtil.replace(path, "\\", "/");								else if (MesquiteFile.fileSeparator.equals("\\"))									path = StringUtil.replace(path, "/", "\\");								if (!MesquiteFile.fileExists(path)){									logln("LowRes Image Missing:  " + path);									countMissing++;								}							}							else								countRemote++;						}					}				}				base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "HighRes";				if (prefixHigh == null)					prefixHigh = getPrefix(base);				paths = getCharacterImages(characterID, k, prefixHigh);				if (paths != null){					int numPaths = getNumberNonNull(paths);					for (int i=0; i<numPaths; i++){						String path = getNonNull(paths, i);						if (path != null){							if (path.indexOf("://")<0) {								countLocal++;								path = base + pathSeparator(base)  + path;								if (MesquiteFile.fileSeparator.equals("/"))									path = StringUtil.replace(path, "\\", "/");								else if (MesquiteFile.fileSeparator.equals("\\"))									path = StringUtil.replace(path, "/", "\\");								if (!MesquiteFile.fileExists(path)){									logln("HighRes Image Missing:  " + path);									countMissing++;								}							}							else								countRemote++;						}					}				}			}		}		if (countLocal == 0)			logln("Missing images can be found only if they are indicated as local; no images are indicated as local");		else if (countMissing == 0)			logln("All images found");		else			logln("Number of missing images: " + countMissing);		logln("Total local images: " + (countLocal));		logln("Total remote images: " + (countRemote));	}	/*-----------------------------------------------------------*/	String[] getTokens(String line){		String[] result;		if (line.indexOf("\t\t")>=0){			StringBuffer sb = new StringBuffer(line);			boolean prev = false;			for (int i=sb.length()-1; i>=0; i--){				if (sb.charAt(i) == '\t'){					if (prev){						sb.insert(i+1, ' ');					}					prev = true;				}				else					prev = false;			}			line = sb.toString();		}		StringTokenizer t = new StringTokenizer(line, "\t");		String tok = null;		int count = t.countTokens();		result = new String[count];		tok = null;		count = 0;		try{			while (t.hasMoreTokens()){				tok = t.nextToken();				if (tok == null)					tok = "";				result[count] = tok;				count++;			}		}		catch (NoSuchElementException e){		}		return result;	}	/*-----------------------------------------------------------*/	public String[][] loadFile(String fileName){		String[] lines = null;		if (indexDirectory.indexOf("://")>=0){			lines = MesquiteFile.getURLContentsAsStrings(indexDirectory + "/" + fileName, false);		}		else			lines = MesquiteFile.getFileContentsAsStrings(indexDirectory + MesquiteFile.fileSeparator + fileName, false);		if (lines == null) {			logln("Attempt to load index file at " + indexDirectory + " failed.");			return null;		}		String[][] result = new String[lines.length][];		for (int i= 0; i<lines.length; i++) {			result[i] = getTokens(lines[i]);		}		return result;	}	/*-----------------------------------------------------------*/	/* for character of this ID, return for each character state [0] = location and [1] = comment*/	String[][] getCharacterImages(String characterID, int i, String prefix){		return getMatches(stateTypeImages, characterID,CharStateImageTypification_CharID, i, CharStateImageTypification_State, CharStateImageTypification_RelativePath,CharStateImageTypification_ImageFileName, CharStateImageTypification_Comment,  prefix);	}	/*-----------------------------------------------------------*/	String[][] getMatches( String[][] list, String target, int columnToMatch, int state, int columnToMatchState, int columnToHarvest, int columnToHarvest2, int commentColumn, String prefix){		if (target == null || list == null)			return null;		int count = 0;		for (int i = 0; i<list.length; i++){			if (list[i] != null && columnToMatch<list[i].length && columnToMatchState<list[i].length && target.equals(list[i][columnToMatch]) && Integer.toString(state).equals(list[i][columnToMatchState]))				count++;		}		String[][] result = new String[count][2];		count = 0;		for (int i = 0; i<list.length; i++){			if (list[i] != null && columnToMatch<list[i].length && columnToMatchState<list[i].length && target.equals(list[i][columnToMatch]) && Integer.toString(state).equals(list[i][columnToMatchState]) && columnToHarvest<list[i].length) {				String s = list[i][columnToHarvest];				if (!StringUtil.blank(s)){					s += pathSeparator(s);					if (prefix != null)						s += prefix;					if (columnToHarvest2>=0)						s += list[i][columnToHarvest2];				}				result[count][0] = s;				result[count][1] = list[i][commentColumn];				count++;			}		}		return result;	}	/*-----------------------------------------------------------*/	String getFirstMatch( String[][] list, String target, int columnToMatch, int columnToHarvest){		if (target == null)			return null;		if (columnToMatch<0 || columnToHarvest<0)			return null;		for (int i = 0; i<list.length; i++){			if (columnToMatch < list[i].length && columnToHarvest<list[i].length && target.equals(list[i][columnToMatch]))				return list[i][columnToHarvest];		}		return null;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	int getNumberNonNull(String[][] paths){		if (paths == null)			return 0;		int count = 0;		for (int i=0; i<paths.length; i++)			if (!StringUtil.blank(paths[i][0]) || !StringUtil.blank(paths[i][1]))				count++;		return count;	}	/*.................................................................................................................*/	String getNonNull(String[][] paths, int whichPath){		if (paths == null)			return null;		int count = 0;		for (int i=0; i<paths.length; i++)			if (!StringUtil.blank(paths[i][0])) {				if (count == whichPath)					return paths[i][0];				count++;			}		return null;	}	/*.................................................................................................................*/	String getNonNullComment(String[][] paths, int whichPath){		if (paths == null)			return null;		int count = 0;		for (int i=0; i<paths.length; i++)			if (true || !StringUtil.blank(paths[i][0])) {				if (count == whichPath)					return paths[i][1];				count++;			}		return null;	}	String getPrefix(String pathToImages){		if (pathToImages.endsWith(MesquiteFile.fileSeparator) || pathToImages.endsWith("/")){			pathToImages += "_prefix.txt";		}		else {			pathToImages += pathSeparator(pathToImages) + "_prefix.txt";		}		String s;		if (pathToImages.indexOf("://")<0) //local			s = MesquiteFile.getFileContentsAsString(pathToImages, 500, 100, false);		else			s = MesquiteFile.getURLContentsAsString(pathToImages, 500, false);		return parser.getFirstToken(s);	}	/*.................................................................................................................*/	public String getCharacterName(CharacterData data, int ic){		if (!ready)			return null;		String characterID = data.getUniqueID(ic);		return getFirstMatch(stateTypeImages, characterID, CharStateImageTypification_CharID, CharStateImageTypification_CharName);	}	public String getCharacterComment(CharacterData data, int ic){		if (!ready)			return null;		String characterID = data.getUniqueID(ic);		return getFirstMatch(stateTypeImages, characterID, CharStateImageTypification_CharID, CharStateImageTypification_CharComment);	}	/*.................................................................................................................*/	public Image[] getCharacterStateImages(int i, CharacterData data, int ic, Vector comment, Vector location){		if (!ready)			return null;		String characterID = data.getUniqueID(ic);		String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";		if (prefixLow == null)			prefixLow = getPrefix(base);		String[][] paths = getCharacterImages(characterID, i, prefixLow);		int numberImages = getNumberNonNull(paths);		Image[] images= new Image[numberImages];		for (int k = 0; k< numberImages; k++){			String path = getNonNull(paths, k);			if (!StringUtil.blank(path)){				if (path.indexOf("://")<0) {					path = base + pathSeparator(base)  + path;					if (MesquiteFile.fileSeparator.equals("/"))						path = StringUtil.replace(path, "\\", "/");					else if (MesquiteFile.fileSeparator.equals("\\"))						path = StringUtil.replace(path, "/", "\\");				}				if (path.indexOf("://")>=0){ //should only massage if path is unmassaged					path = StringUtil.encodeForURL(path);					path = StringUtil.replace(path, "\\", "/");				}				images[k] = MesquiteImage.getImage(path, false);				MesquiteImage.waitForImageToLoad(images[k]);			}			if (path == null)				path = "";			if (location!= null)				location.addElement(path);			if (comment!= null){				String com = getNonNullComment(paths, k);				comment.addElement(com);			}		}		return  images;	}	/*.................................................................................................................*/	public int getMaxStateWithImages(CharacterData data, int ic){		if (!ready)			return 0;		String characterID = data.getUniqueID(ic);		String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";		if (prefixLow == null)			prefixLow = getPrefix(base);		int max = -1;		for (int i=0; i<=CategoricalState.maxCategoricalState; i++){			String[][] paths = getCharacterImages(characterID, i, prefixLow);			int numberImages = getNumberNonNull(paths);			if (numberImages>0)				max = i;		}		return  max;	}	/*.................................................................................................................*/	/* returns for each character state the number of images for it */	public int[] getNumCharacterStateImages(CharacterData data, int ic){		if (!ready)			return null;		int maxState = ((CategoricalData)data).maxStateWithDefinition(ic);		int mswi = getMaxStateWithImages(data, ic);		if (mswi>maxState)			maxState = mswi;		String characterID = data.getUniqueID(ic);		int[] nums = new int[ maxState+1];		for (int k = 0; k<= maxState; k++){			String[][] paths = getCharacterImages(characterID, k, "");			int num = getNumberNonNull(paths);			nums[k] =num;		}		return nums;	}	/*		String[][] paths = getCharacterImages(characterID, i, prefixLow);		int numberImages = getNumberNonNull(paths);		Image[] images= new Image[numberImages];		for (int k = 0; k< numberImages; k++){			String path = getNonNull(paths, k);			if (path != null){			if (path.indexOf("://")<0) {				path = base + pathSeparator(base)  + path;				if (MesquiteFile.fileSeparator.equals("/"))					path = StringUtil.replace(path, "\\", "/");				else if (MesquiteFile.fileSeparator.equals("\\"))					path = StringUtil.replace(path, "/", "\\");			}			if (path.indexOf("://")>=0){ //should only massage if path is unmassaged				path = StringUtil.encodeForURL(path);				path = StringUtil.replace(path, "\\", "/");			}			images[k] = MesquiteImage.getImage(path, false);			MesquiteImage.waitForImageToLoad(images[k]);			if (comment!= null)				comment.addElement(getNonNullComment(paths, k));			if (location!= null)				location.addElement(path);			}		}	}	/*.................................................................................................................*/	/* i is the ith in sequence, across states */	public boolean showCloseupCharImage(int whichImage, CharacterData data, int ic, int modifiers){		if (!ready)			return false;		String characterID = data.getUniqueID(ic);		String baseLow = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";		String baseHigh = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "HighRes";		String prefixLow = getPrefix(baseLow);		String prefixHigh = getPrefix(baseHigh);		String base = null;		/*if (MesquiteEvent.optionKeyDown(modifiers)){			base = baseLow;			if (prefixLow == null)				prefixLow = getPrefix(base);			prefix = prefixLow;		}		else {			base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "HighRes";			if (prefixHigh == null)				prefixHigh = getPrefix(base);			prefix = prefixHigh;		}*/		int countImages = -1;		int targetImage = -1;		int targetState = -1;		String imagePathLow = null;  //check low first because that's what the request is based on		for (int state = 0; state<=CategoricalState.maxCategoricalState && StringUtil.blank(imagePathLow); state++){			String[][] paths = getCharacterImages(characterID, state, prefixLow);			int numberImages = getNumberNonNull(paths);			for (int k = 0; k< numberImages && StringUtil.blank(imagePathLow); k++){				imagePathLow = getNonNull(paths, k);				if (!StringUtil.blank(imagePathLow)){					countImages++;					if (countImages != whichImage)						imagePathLow = null;					else {						targetState = state;						targetImage = k;					}				}			}		}		imagePathLow = baseLow + pathSeparator(baseLow)  + imagePathLow;		if (targetImage <0)			return false;		String imagePathHigh = null;  //check low first because that's what the request is based on		String[][] paths = getCharacterImages(characterID, targetState, prefixHigh);		imagePathHigh = getNonNull(paths, targetImage);		String imagePath = null;		if (StringUtil.blank(imagePathHigh)) {  //high certainly no good			if (imagePathLow.indexOf("://")>=0){ //should only massage if path is unmassaged				imagePath = StringUtil.encodeForURL(imagePathLow);				imagePath = StringUtil.replace(imagePath, "\\", "/");			}			else {				imagePath = baseLow + pathSeparator(baseLow)  + imagePathLow;				if (MesquiteFile.fileSeparator.equals("/"))					imagePath = StringUtil.replace(imagePath, "\\", "/");				else if (MesquiteFile.fileSeparator.equals("\\"))					imagePath = StringUtil.replace(imagePath, "/", "\\");			}		}		else {			imagePath = baseHigh + pathSeparator(baseHigh)  + imagePathHigh;			if (imagePath.indexOf("://")>=0){ //should only massage if path is unmassaged				imagePath = StringUtil.encodeForURL(imagePath);				imagePath = StringUtil.replace(imagePath, "\\", "/");			}			else {  //high local				if (MesquiteFile.fileSeparator.equals("/"))					imagePath = StringUtil.replace(imagePath, "\\", "/");				else if (MesquiteFile.fileSeparator.equals("\\"))					imagePath = StringUtil.replace(imagePath, "/", "\\");				if (!MesquiteFile.fileExists(imagePath)){					imagePath = imagePathLow;					if (MesquiteFile.fileSeparator.equals("/"))						imagePath = StringUtil.replace(imagePath, "\\", "/");					else if (MesquiteFile.fileSeparator.equals("\\"))						imagePath = StringUtil.replace(imagePath, "/", "\\");				}			}		}		String viewer = "open";		logln("Opening image file at " + imagePath);		if (!MesquiteTrunk.isMacOSX()){			viewer = indexManager.getViewer(imagePath);			if (viewer == null)				viewer = "open";			imagePath = "\"" + imagePath + "\"";		}		//String viewer = "C:\\Program Files\\ACD Systems\\ACDSee\\ACDSee.exe";		//String imagePath = "\"" + directory + MesquiteFile.fileSeparator + getNonNull(paths, i) + "\"";		try {			Process p = Runtime.getRuntime().exec(new String[]{ viewer, imagePath});			return true;		}		catch (IOException e){			MesquiteMessage.println("exception in showCloseupCellImage ");			MesquiteFile.throwableToLog(this, e);		}		return false;	}	/*.................................................................................................................*/	public String getName() {		return "Indexed Character State Images";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Gives images for a character from indexed storage." ;	}}