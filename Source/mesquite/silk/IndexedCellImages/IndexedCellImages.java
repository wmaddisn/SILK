/* SILK source code.  Copyright 2007-2009 W. Maddison and M. Ramirez.   Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code.  The commenting leaves much to be desired. Please approach this source code with the spirit of helping out. Perhaps with your help we can be more than a few, and make Mesquite better. Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY. Mesquite's web site is http://mesquiteproject.org This source code and its compiled class files are free and modifiable under the terms of  GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.silk.IndexedCellImages; import java.util.*;import java.awt.*;import java.io.*;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.taxa.Taxa;import mesquite.lib.ui.MesquiteImage;import mesquite.lib.ui.MesquiteWindow;import mesquite.silk.lib.*;/** ======================================================================== */public class IndexedCellImages extends CellImageSource implements IndexListener {	String indexDirectory = null;	String imageDirectoryBase = null; 	String prefixLow = null;	String prefixHigh = null;	CharacterData data = null;	String relativeDirectory = "";	ImageIndexManager indexManager;	//positions of columns in each table	int TaxaToTerminals_TaxonNameInMatrix = -1;	int TaxaToTerminals_TaxonUniqueIDInMatrix = -1;	int[] TaxaToTerminals_ImageTaxonID = new int[100];	int[] TaxaToTerminals_ImageTaxonID_TEMP = new int[100];	int CharsToMorphology_CharID = -1;	int[] CharsToMorphology_MorphologyID = new int[100];	int[] CharsToMorphology_MorphologyID_TEMP  = new int[100];	int ImageData_ImageTaxonID = -1;	int ImageData_MorphologyID = -1;	int ImageData_Comment = -1;	int ImageData_ImageFileName = -1;	int ImageData_RelativePath = -1;	String notReadyMessage = "Reading Image Indices... ";	NumCellImagesThread numThread;	/*========NEW SYSTEM=========*/	String[] indexedTaxonUniqueIDs; //use this to find local taxon number	String[] indexedTaxonNames; //or use this to find local taxon number	String[] imageTaxonIDs; // use this to find number of image taxon	//now use the following to find imageTaxa that correspond	int[][] imageTaxaForIndexedTaxa;  //each row is list of imageTaxon numbers for a taxon (taxa numbered locally, not as currently in matrix)	String[] indexedCharacterUniqueIDs; //use this to find local character number	String[] standardViewNames; //use this to find standard view number	//now use the following to find standard views that correspond	int[][] standardViewsForIndexedChars; //each row is a list of standard views for a character (chars numbered locally)	//this holds the image data; each string is the whole line from the text	String[][][] imageData;  //imageData[i][k][n] is the nth line for the ith image taxon and the kth standard view	long[][][] imageDataFilePos;  //imageData[i][k][n] is the nth line for the ith image taxon and the kth standard view	int COMMENT = 0;	int IMAGEFILENAME = 1;	int RELATIVEPATH = 2;	/*=========================*/	//OLD SYSTEM	/*	 characterID stateNumber path1 path2 ...	 characterID2 stateNumber  path1 path2 ...	 */	//String[][] formalTaxaToImageTaxa;  	/*	 taxonID imageTaxon1 imageTaxon2 ...	 taxonID imageTaxon1 imageTaxon2 ...	String[][] charsToStandardViews;  	String[][] imagePaths = null;	String[] imagePathsCompact = null;	int[][] imagePathLinks = null;	/*	 standardView imageTaxon path	 standardView imageTaxon path	 */	boolean ready = false;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		indexManager =(ImageIndexManager)findNearestColleagueWithDuty(ImageIndexManager.class);		if (!MesquiteThread.isScripting()){			requestLoadIndices();		}		loadPreferences();		addMenuItem( "Search for Missing Images...", makeCommand("searchMissing",  this));		if (indexManager != null)			indexManager.addListener(this);		return true;	}	public void endJob(){		try{			if (this.data != null){				this.data.removeListener(this);				data.getTaxa().removeListener(this);			}			indexManager.removeListener(this);			numThread.stopThread();		}		catch (Exception e){		}		super.endJob();	}	public void indexChanged(){		indexDirectory = null;		imageDirectoryBase = null;		prefixLow = null;		prefixHigh = null;		requestLoadIndices();	}	public void imagesChanged(){		imageDirectoryBase = indexManager.getImageRootPath();		prefixLow = null;		prefixHigh = null;		parametersChanged();	}	void requestLoadIndices(){				if (indexDirectory == null){			indexDirectory = indexManager.getIndexDirectory();			relativeDirectory = MesquiteFile.decomposePath(getProject().getHomeFile().getDirectoryName(), indexDirectory);		}		if (imageDirectoryBase == null)			imageDirectoryBase = indexManager.getImageRootPath();		logln("Request to load indices for images: " + indexDirectory);		if (StringUtil.blank(indexDirectory))			return;		indexManager.requestLoadIndices(this);	}	private void findColumnsTaxaToTerminals(String[][] table){		if (table == null || table.length == 0 || table[0].length == 0)			return;		int count = 0;		for (int i = 0; i< TaxaToTerminals_ImageTaxonID_TEMP.length; i++)			TaxaToTerminals_ImageTaxonID_TEMP[i] = -1;		for (int i=0; i< table[0].length; i++){			if (table[0][i] != null){				if (table[0][i].equalsIgnoreCase("TaxonNameInMatrix"))					TaxaToTerminals_TaxonNameInMatrix = i;				else if (table[0][i].equalsIgnoreCase("TaxonUniqueIDInMatrix"))					TaxaToTerminals_TaxonUniqueIDInMatrix = i;				else if (table[0][i].equalsIgnoreCase("ImageTaxonID") && count<100)					TaxaToTerminals_ImageTaxonID_TEMP[count++] = i;			}		}		int[] compact = new int[count];		count = 0;		for (int i = 0; i< TaxaToTerminals_ImageTaxonID_TEMP.length; i++)			if (TaxaToTerminals_ImageTaxonID_TEMP[i]>=0)				compact[count++] = TaxaToTerminals_ImageTaxonID_TEMP[i];		TaxaToTerminals_ImageTaxonID = compact;	}	private void findColumnsCharsToMorphology(String[][] table){		if (table == null || table.length == 0 || table[0].length == 0)			return;		for (int i = 0; i< CharsToMorphology_MorphologyID_TEMP.length; i++)			CharsToMorphology_MorphologyID_TEMP[i] = -1;		int count = 0;		for (int i=0; i< table[0].length; i++){			if (table[0][i] != null){				if (table[0][i].equalsIgnoreCase( "CharID"))					CharsToMorphology_CharID = i;				else if (table[0][i].equalsIgnoreCase("MorphologyID") && count<100)					CharsToMorphology_MorphologyID_TEMP[count++] = i;			}		}		int[] compact = new int[count];		count = 0;		for (int i = 0; i< CharsToMorphology_MorphologyID_TEMP.length; i++)			if (CharsToMorphology_MorphologyID_TEMP[i]>=0)				compact[count++] = CharsToMorphology_MorphologyID_TEMP[i];		CharsToMorphology_MorphologyID = compact;	}	/*	private void findColumnsImageData(String[] table){		if (table == null || table.length == 0)			return;		String[] firstLine = getTokens(table[0], new StringBuffer());		for (int i=0; i< firstLine.length; i++){			if (firstLine[i] != null){				if (firstLine[i].equalsIgnoreCase("ImageTaxonID"))					ImageData_ImageTaxonID = i;				else if (firstLine[i].equalsIgnoreCase("MorphologyID"))					ImageData_MorphologyID = i;				else if (firstLine[i].equalsIgnoreCase("Comment"))					ImageData_Comment = i;				else if (firstLine[i].equalsIgnoreCase("ImageFileName"))					ImageData_ImageFileName = i;				else if (firstLine[i].equalsIgnoreCase("RelativePath"))					ImageData_RelativePath = i;			}		}	}	 */	public void setData(CharacterData data){		this.data = data;	}	public CharacterData getData(){		return data;	}	public boolean loadIndices(){		notReadyMessage = "Reading Image Indices... ";		parametersChanged(new Notification(IMAGESNOTREADY));		logln("\nLoading index files from " + indexDirectory + "\n");		MesquiteWindow.tickClock("Loading Standard Views index");		log("Loading Standard views index... ");		String[][] charsToStandardViews = loadFileTable("CharsToMorphology.txt");		findColumnsCharsToMorphology(charsToStandardViews);		processCharacterTable(charsToStandardViews);		if (charsToStandardViews != null)			logln(" loaded");		else{			notReadyMessage = "Index loading failed";			logln(" LOADING FAILED");			parametersChanged(new Notification(IMAGESNOTREADY));			return false;		}				log("Loading taxon synonymy index... ");		String[][] formalTaxaToImageTaxa = loadFileTable("TaxaToTerminals.txt");		MesquiteWindow.tickClock("Loading taxon synonymy index");		findColumnsTaxaToTerminals(formalTaxaToImageTaxa);		processTaxonTable(formalTaxaToImageTaxa);		if (formalTaxaToImageTaxa != null)			logln(" loaded");		else{			notReadyMessage = "Index loading failed";			logln(" LOADING FAILED");			parametersChanged(new Notification(IMAGESNOTREADY));			return false;		}		log("Loading image paths index...");		MesquiteWindow.tickClock("Loading image paths index");		processImagesTable("ImageData.txt");		MesquiteWindow.hideClock();		if (imageDataFilePos != null)			logln(" loaded");		else{			notReadyMessage = "Index loading failed";			logln(" LOADING FAILED");			parametersChanged(new Notification(IMAGESNOTREADY));			return false;		}		ready = (charsToStandardViews != null && formalTaxaToImageTaxa != null && (imageDataFilePos != null));		if (ready) {			parametersChanged(new Notification(IMAGESREADY));		}		else {			notReadyMessage = "Indices failed to load; confirm Indexed Image Location.";			parametersChanged(new Notification(IMAGESNOTREADY));		}		if (numThread == null){			numThread = new NumCellImagesThread(this, data);			numThread.start();		}		else 			numThread.setStatus(0);		return true;	}	String[] removeAndTransfer(String[] a, int ir){		String[] b = new String[a.length - 1];		for (int i = 0; i < a.length; i++){			if (i > ir)				b[i-1] = a[i];			else if (i<ir)				b[i] = a[i];		}		return b;	}	String[] expandAndTransfer(String[] a){		if (a == null || a.length == 0)			return new String[1];		String[] b = new String[a.length + 1];		for (int i = 0; i < a.length; i++)			b[i] = a[i];		return b;	}	long[] expandAndTransfer(long[] a){		if (a == null || a.length == 0)			return new long[1];		long[] b = new long[a.length + 1];		for (int i = 0; i < a.length; i++)			b[i] = a[i];		return b;	}	/*_________________________________________________*/	String imageDataPath = null;	void processImagesTable(String fileName){		imageDataFilePos = new long[imageTaxonIDs.length][standardViewNames.length][0];  //start off with n = 1 and bump up		StringBuffer sb = new StringBuffer();		imageDataPath = indexDirectory + MesquiteFile.fileSeparator + fileName;		//this holds the image data; each string is the whole line from the text		//String[][] imageData;  //imageData[i][k] is the line for the ith image taxon and the kth standard view		//	ImageData_ImageTaxonID ImageData_MorphologyID 	ImageData_Comment  ImageData_ImageFileName  ImageData_RelativePath;		try {			DataInputStream imagesDataStream = new DataInputStream(new FileInputStream(imageDataPath));			String newS = " ";			StringBuffer sBb= new StringBuffer(100);			MesquiteInteger remnant = new MesquiteInteger(-1);			boolean first = true;			int count = 0;			MesquiteLong filePos = new MesquiteLong(0);			while (newS != null) {				long prevPosition = filePos.getValue();				newS =MesquiteFile.readLine(imagesDataStream, sBb, remnant, filePos);				if (newS != null){					String[] tokens = getTokens(newS, sb);					if (first){						first = false;						for (int i=0; i< tokens.length; i++){							if (tokens[i] != null){								if (tokens[i].equalsIgnoreCase("ImageTaxonID"))									ImageData_ImageTaxonID = i;								else if (tokens[i].equalsIgnoreCase("MorphologyID"))									ImageData_MorphologyID = i;								else if (tokens[i].equalsIgnoreCase("Comment"))									ImageData_Comment = i;								else if (tokens[i].equalsIgnoreCase("ImageFileName"))									ImageData_ImageFileName = i;								else if (tokens[i].equalsIgnoreCase("RelativePath"))									ImageData_RelativePath = i;							}						}					}					else {						if (++count % 5000 == 0)							logln("reading line " + count);						String imageTaxonID = tokens[ImageData_ImageTaxonID];						int imageTaxonNumber = StringArray.indexOf(imageTaxonIDs, imageTaxonID);						String standardView = tokens[ImageData_MorphologyID];						int standardViewNumber = StringArray.indexOf(standardViewNames, standardView);						if (imageTaxonNumber >=0 && imageTaxonNumber< imageDataFilePos.length && standardViewNumber >= 0 && standardViewNumber < imageDataFilePos[imageTaxonNumber].length){							int n = imageDataFilePos[imageTaxonNumber][standardViewNumber].length -1;							if (n < 0 || imageDataFilePos[imageTaxonNumber][standardViewNumber][n] >0){								//already filled; need to expand array								imageDataFilePos[imageTaxonNumber][standardViewNumber] = expandAndTransfer(imageDataFilePos[imageTaxonNumber][standardViewNumber]);								n++;							}							long position = filePos.getValue();						//	if (remnant.isCombinable() && remnant.getValue() >0)						//		position -= remnant.getValue();							imageDataFilePos[imageTaxonNumber][standardViewNumber][n] = prevPosition;  						}					}				}			}		}		catch( FileNotFoundException e ) {			MesquiteMessage.warnProgrammer("File Busy or Not Found (" + getName() + ") : " + imageDataPath);			imageDataPath = null;			MesquiteFile.throwableToLog(null, e);			return;		} 		/*//clean up elements with blanks		for (int it = 0; it<imageData.length; it++)			for (int isv = 0; isv < imageData[it].length; isv++)				for (int ir = 0; ir< imageData[it][isv][COMMENT].length; ir++){					if (StringUtil.blank(imageData[it][isv][IMAGEFILENAME][ir])){						imageData[it][isv][COMMENT] = removeAndTransfer(imageData[it][isv][COMMENT], ir);						imageData[it][isv][IMAGEFILENAME] = removeAndTransfer(imageData[it][isv][IMAGEFILENAME], ir);						imageData[it][isv][RELATIVEPATH] = removeAndTransfer(imageData[it][isv][RELATIVEPATH], ir);					}				}*/	}	String getImageData(int imageTaxonNumber, int standardViewNumber, int i){		if (imageDataPath == null)			return null;		if (imageDataFilePos == null || imageTaxonNumber>=imageDataFilePos.length)			return null;		if (imageDataFilePos[imageTaxonNumber] == null || standardViewNumber>=imageDataFilePos[imageTaxonNumber].length)			return null;		if (imageDataFilePos[imageTaxonNumber][standardViewNumber] == null || i>=imageDataFilePos[imageTaxonNumber][standardViewNumber].length)			return null;		try {			DataInputStream imagesDataStream = new DataInputStream(new FileInputStream(imageDataPath));			imagesDataStream.skip(imageDataFilePos[imageTaxonNumber][standardViewNumber][i]);			StringBuffer sBb= new StringBuffer(100);			MesquiteInteger remnant = new MesquiteInteger(-1);			StringBuffer sb = new StringBuffer();			String newS =MesquiteFile.readLine(imagesDataStream, sBb, remnant);			if (newS != null){				String[] tokens = getTokens(newS, sb);				return tokens[ImageData_Comment] + (char)(2) +  tokens[ImageData_ImageFileName] + (char)2 + tokens[ImageData_RelativePath];			}		}		catch (Exception e){		}		return null;	}	int getNumImageData(int imageTaxonNumber, int standardViewNumber){		if (imageDataPath == null)			return 0;		if (imageDataFilePos == null || imageTaxonNumber>=imageDataFilePos.length)			return 0;		if (imageDataFilePos[imageTaxonNumber] == null || standardViewNumber>=imageDataFilePos[imageTaxonNumber].length)			return 0;		if (imageDataFilePos[imageTaxonNumber][standardViewNumber] == null)			return 0;		return imageDataFilePos[imageTaxonNumber][standardViewNumber].length;	}	/*_________________________________________________*/	void OLDprocessImagesTable(String fileName){		imageData = new String[imageTaxonIDs.length][standardViewNames.length][0];  //start off with n = 1 and bump up		StringBuffer sb = new StringBuffer();		String path = indexDirectory + MesquiteFile.fileSeparator + fileName;		//this holds the image data; each string is the whole line from the text		//String[][] imageData;  //imageData[i][k] is the line for the ith image taxon and the kth standard view		//	ImageData_ImageTaxonID ImageData_MorphologyID 	ImageData_Comment  ImageData_ImageFileName  ImageData_RelativePath;		try {			DataInputStream stream = new DataInputStream(new FileInputStream(path));			String newS = " ";			StringBuffer sBb= new StringBuffer(100);			MesquiteInteger remnant = new MesquiteInteger(-1);			boolean first = true;			int count = 0;			while (newS != null) {				newS =MesquiteFile.readLine(stream, sBb, remnant);				if (newS != null){					String[] tokens = getTokens(newS, sb);					if (first){						first = false;						for (int i=0; i< tokens.length; i++){							if (tokens[i] != null){								if (tokens[i].equalsIgnoreCase("ImageTaxonID"))									ImageData_ImageTaxonID = i;								else if (tokens[i].equalsIgnoreCase("MorphologyID"))									ImageData_MorphologyID = i;								else if (tokens[i].equalsIgnoreCase("Comment"))									ImageData_Comment = i;								else if (tokens[i].equalsIgnoreCase("ImageFileName"))									ImageData_ImageFileName = i;								else if (tokens[i].equalsIgnoreCase("RelativePath"))									ImageData_RelativePath = i;							}						}					}					else {						if (++count % 5000 == 0)							logln("reading line " + count);						String imageTaxonID = tokens[ImageData_ImageTaxonID];						int imageTaxonNumber = StringArray.indexOf(imageTaxonIDs, imageTaxonID);						String standardView = tokens[ImageData_MorphologyID];						int standardViewNumber = StringArray.indexOf(standardViewNames, standardView);						if (imageTaxonNumber >=0 && imageTaxonNumber< imageData.length && standardViewNumber >= 0 && standardViewNumber < imageData[imageTaxonNumber].length){							int n = imageData[imageTaxonNumber][standardViewNumber].length -1;							if (n < 0 || imageData[imageTaxonNumber][standardViewNumber][n] != null){								//already filled; need to expand array								imageData[imageTaxonNumber][standardViewNumber] = expandAndTransfer(imageData[imageTaxonNumber][standardViewNumber]);								n++;							}							imageData[imageTaxonNumber][standardViewNumber][n] = tokens[ImageData_Comment] + (char)(2) +  tokens[ImageData_ImageFileName] + (char)2 + tokens[ImageData_RelativePath];						}					}				}			}		}		catch( FileNotFoundException e ) {			MesquiteMessage.warnProgrammer("File Busy or Not Found (" + getName() + ") : " + path);			MesquiteFile.throwableToLog(null, e);			return;		} 		/*//clean up elements with blanks		for (int it = 0; it<imageData.length; it++)			for (int isv = 0; isv < imageData[it].length; isv++)				for (int ir = 0; ir< imageData[it][isv][COMMENT].length; ir++){					if (StringUtil.blank(imageData[it][isv][IMAGEFILENAME][ir])){						imageData[it][isv][COMMENT] = removeAndTransfer(imageData[it][isv][COMMENT], ir);						imageData[it][isv][IMAGEFILENAME] = removeAndTransfer(imageData[it][isv][IMAGEFILENAME], ir);						imageData[it][isv][RELATIVEPATH] = removeAndTransfer(imageData[it][isv][RELATIVEPATH], ir);					}				}*/	}	String OLDgetImageData(int imageTaxonNumber, int standardViewNumber, int i){		if (imageData == null || imageTaxonNumber>=imageData.length)			return null;		if (imageData[imageTaxonNumber] == null || standardViewNumber>=imageData[imageTaxonNumber].length)			return null;		if (imageData[imageTaxonNumber][standardViewNumber] == null || i>=imageData[imageTaxonNumber][standardViewNumber].length)			return null;		return imageData[imageTaxonNumber][standardViewNumber][i];	}	int OLDgetNumImageData(int imageTaxonNumber, int standardViewNumber){		if (imageData == null || imageTaxonNumber>=imageData.length)			return 0;		if (imageData[imageTaxonNumber] == null || standardViewNumber>=imageData[imageTaxonNumber].length)			return 0;		if (imageData[imageTaxonNumber][standardViewNumber] == null)			return 0;		return imageData[imageTaxonNumber][standardViewNumber].length;	}	/*_________________________________________________*/	void processTaxonTable(String[][] taxonTable){		if (taxonTable == null)			return;		//String[] indexedTaxonUniqueIDs; //use this to find local taxon number		//String[] indexedTaxonNames; //or use this to find local taxon number		//now use the following to find imageTaxa that correspond		//int[][] imageTaxaForIndexedTaxa;  //each row is list of imageTaxon numbers for a taxon (taxa numbered locally, not as currently in matrix)		//String[] imageTaxonIDs; //use this to find local taxon number		Vector taxonNames = new Vector();  //will record list of sv's		Vector taxonIDs = new Vector();  //will record taxon id's in order received		Vector imageTaxaForTaxa = new Vector(); //same order as previous; will record list of imageTaxon numbers		Vector imageTaxaNames = new Vector(); //known  image taxa names		for (int i= 1; i< taxonTable.length; i++){			int localTaxonNumber = -1;			String taxonID = null;			String taxonName = null;			if (TaxaToTerminals_TaxonUniqueIDInMatrix>=0 && TaxaToTerminals_TaxonUniqueIDInMatrix< taxonTable[i].length){				taxonID = taxonTable[i][TaxaToTerminals_TaxonUniqueIDInMatrix];				localTaxonNumber = StringArray.indexOf(taxonIDs, taxonID);  //finding local taxon number from id			}			if (TaxaToTerminals_TaxonNameInMatrix>=0 && TaxaToTerminals_TaxonNameInMatrix< taxonTable[i].length)				taxonName = taxonTable[i][TaxaToTerminals_TaxonNameInMatrix];			if (localTaxonNumber<0){				localTaxonNumber = StringArray.indexOf(taxonNames, taxonName);  //finding local taxon number from name				if (localTaxonNumber < 0){					if (!StringUtil.blank(taxonName) || !StringUtil.blank(taxonID)){						localTaxonNumber = taxonNames.size();						taxonNames.addElement(taxonName);						taxonIDs.addElement(taxonID);						imageTaxaForTaxa.addElement(new IntegerArray(0, 1));					}				}			}			if (localTaxonNumber>=0){				IntegerArray imageTaxa = (IntegerArray)imageTaxaForTaxa.elementAt(localTaxonNumber);				for (int k = 0; k< TaxaToTerminals_ImageTaxonID.length; k++){					if (TaxaToTerminals_ImageTaxonID[k]< taxonTable[i].length){						String imageTaxonName = taxonTable[i][TaxaToTerminals_ImageTaxonID[k]];						int imageTaxonNumber = StringArray.indexOf(imageTaxaNames, imageTaxonName);  //finding sv number from name						if (imageTaxonNumber < 0 ){							imageTaxonNumber = imageTaxaNames.size();							imageTaxaNames.addElement(imageTaxonName);						}						imageTaxa.setValue(imageTaxa.getSize(), imageTaxonNumber);					}				}			}		}		indexedTaxonUniqueIDs = new String[taxonIDs.size()];		indexedTaxonNames = new String[taxonIDs.size()];		for (int i=0; i<taxonIDs.size(); i++){			indexedTaxonUniqueIDs[i] = (String)taxonIDs.elementAt(i);			indexedTaxonNames[i] = (String)taxonNames.elementAt(i);		}		imageTaxaForIndexedTaxa = new int[imageTaxaForTaxa.size()][];		for (int i=0; i<imageTaxaForTaxa.size(); i++){			imageTaxaForIndexedTaxa[i] = ((IntegerArray)imageTaxaForTaxa.elementAt(i)).getMatrix();		}		imageTaxonIDs = new String[imageTaxaNames.size()];		for (int i=0; i<imageTaxaNames.size(); i++){			imageTaxonIDs[i] = (String)imageTaxaNames.elementAt(i);		}	}	/*_________________________________________________*/	/*_________________________________________________*/	void processCharacterTable(String[][] cToSVs){		if (cToSVs == null)			return;		//String[] indexedCharacterUniqueIDs; //use this to find local character number		//now use the following to find standard views that correspond		//int[][] standardViewsForIndexedChars; //each row is a list of standard views for a character (chars numbered locally)		//String[] standardViewNames		Vector standardViews = new Vector();  //will record list of sv's		Vector characters = new Vector();  //will record char id's in order received		Vector svsForCharacters = new Vector(); //same order as previous; will record list of sv numbers		for (int i= 1; i< cToSVs.length; i++){			String charID = cToSVs[i][CharsToMorphology_CharID];			int localCharNumber = StringArray.indexOf(characters, charID);  //finding local character number from id			if (localCharNumber<0){				localCharNumber = characters.size();				characters.addElement(charID);				svsForCharacters.addElement(new IntegerArray(0, 1));			}			IntegerArray svs = (IntegerArray)svsForCharacters.elementAt(localCharNumber);			for (int k = 0; k< CharsToMorphology_MorphologyID.length; k++){				if (CharsToMorphology_MorphologyID[k]<cToSVs[i].length){					String svName = cToSVs[i][CharsToMorphology_MorphologyID[k]];					if (!StringUtil.blank(svName)){						int svNumber = StringArray.indexOf(standardViews, svName);  //finding sv number from name						if (svNumber < 0 ){							svNumber = standardViews.size();							standardViews.addElement(svName);						}						svs.setValue(svs.getSize(), svNumber);					}				}			}		}		indexedCharacterUniqueIDs = new String[characters.size()];		for (int i=0; i<characters.size(); i++){			indexedCharacterUniqueIDs[i] = (String)characters.elementAt(i);		}		standardViewNames = new String[standardViews.size()];		for (int i=0; i<standardViews.size(); i++){			standardViewNames[i] = (String)standardViews.elementAt(i);		}		standardViewsForIndexedChars = new int[svsForCharacters.size()][];		for (int i=0; i<svsForCharacters.size(); i++){			standardViewsForIndexedChars[i] = ((IntegerArray)svsForCharacters.elementAt(i)).getMatrix();		}	}	/*_________________________________________________*/	/*_________________________________________________*/	public String waitingMessage(){		if (!ready) {			return notReadyMessage;		}		return null;	}	String pathSeparator(String before){		if (indexManager== null) {			if (before == null || !before.endsWith("/"))				return "/";		}		else if (indexManager.useLocalImages()) {			if (before == null || !before.endsWith(MesquiteFile.fileSeparator))				return MesquiteFile.fileSeparator;		}		else {			if (before == null || !before.endsWith("/"))				return "/";		}		return "";	}	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot temp = new Snapshot();		temp.addLine("load");		return temp;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Loads indices", null, commandName, "load")) {			requestLoadIndices();		}		else if (checker.compare(this.getClass(), "Search for missing images", null, commandName, "searchMissing")) {			if (indexDirectory == null)				requestLoadIndices();			scanImages();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	public void scanImages(){		if (data == null)			return;		/*		 * 	 int[] getNumCellImages(CharacterData data, int ic, int it){			 getCellImage(int i, CharacterData data, int ic, int it, MesquiteString comment, MesquiteString location){		}		 */		logln("");		int countLocal =0;		int countRemote = 0;		int countMissing = 0;		for (int ic = 0; ic<data.getNumChars(); ic++)			for (int it = 0; it<data.getNumTaxa(); it++){				int[] numIm = getNumCellImages(data, ic, it);				String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";				if (prefixLow == null)					prefixLow = getPrefix(base);				String baseHigh = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "HighRes";				if (prefixHigh == null)					prefixHigh = getPrefix(baseHigh);				for (int k=0; numIm != null && k< numIm.length; k++){					String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it), prefixLow);					boolean[] unique = calculateUnique(paths);					String path = getNonNull(paths, k, unique);					if (path != null) {						if (path.indexOf("://")<0) {							countLocal++;							path = base + pathSeparator(base)  + path;							if (MesquiteFile.fileSeparator.equals("/"))								path = StringUtil.replace(path, "\\", "/");							else if (MesquiteFile.fileSeparator.equals("\\"))								path = StringUtil.replace(path, "/", "\\");							if (!MesquiteFile.fileExists(path)){								logln("LowRes Image Missing:  " + path);								countMissing++;							}						}						else{							countRemote++;						}					}					paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it), prefixHigh);					unique = calculateUnique(paths);					path = getNonNull(paths, k, unique);					if (path != null) {						countLocal++;						if (path.indexOf("://")<0) {							path = baseHigh + pathSeparator(base)  + path;							if (MesquiteFile.fileSeparator.equals("/"))								path = StringUtil.replace(path, "\\", "/");							else if (MesquiteFile.fileSeparator.equals("\\"))								path = StringUtil.replace(path, "/", "\\");							if (!MesquiteFile.fileExists(path)){								logln("HighRes Image Missing:  " + path);								countMissing++;							}						}						else { 							countRemote++;						}					}				}			}		showLogWindow();		logln("----------");		logln("Summary of images found");		if (countLocal == 0)			logln("Missing images can be found only if they are indicated as local; no images are indicated as local");		else if (countMissing == 0)			logln("All images found");		else			logln("Number of missing images: " + countMissing);		logln("Total local images: " + (countLocal));		logln("Total remote images: " + (countRemote));	}	/*-----------------------------------------------------------*/	String prepareLine(String line, StringBuffer sb){		if (line.indexOf("\t\t")>=0){			sb.setLength(0);			sb.append(line);			boolean prev = false;			for (int i=sb.length()-1; i>=0; i--){				if (sb.charAt(i) == '\t'){					if (prev){						sb.insert(i+1, ' ');					}					prev = true;				}				else					prev = false;			}			return sb.toString();		}		return line;	}	/*-----------------------------------------------------------*/	String[] getTokens(String line, StringBuffer sb){		String[] result;		line = prepareLine(line, sb);		StringTokenizer t = new StringTokenizer(line, "\t");		String tok = null;		int count = t.countTokens();		/*try{			while ((tok = t.nextToken())!= null) {				count++;			}		}		catch (NoSuchElementException e){		}*/		result = new String[count];		//	StringTokenizer t2 = new StringTokenizer(line, "\t");		tok = null;		count = 0;		try{			while (t.hasMoreTokens()){				tok = t.nextToken();				if (tok == null)					tok = "";				result[count] = tok;				count++;			}		}		catch (NoSuchElementException e){		}		return result;	}	/*-----------------------------------------------------------*/	public String[][] loadFileTable(String fileName){		String[] lines = null;		if (indexDirectory.indexOf("://")>=0){			lines = MesquiteFile.getURLContentsAsStrings(indexDirectory + "/" + fileName, false);		}		else {			lines = MesquiteFile.getFileContentsAsStrings(indexDirectory + MesquiteFile.fileSeparator + fileName, false);		}		if (lines == null)			return null;		String[][] result = new String[lines.length][];		StringBuffer sb = new StringBuffer();		for (int i= 0; i<lines.length; i++) {			result[i] = getTokens(lines[i], sb);			lines[i] = null;			if (i % 1000 == 0)				log(".");		}		if (result != null && result.length>0){			String s = " ";			for (int i= 0; i<result[0].length; i++) {				s += result[0][i] + " ";			}			//	logln("File read with headings " + s);		}		return result;	}	/*-----------------------------------------------------------*/	public String[] loadFileLines(String fileName){		String[] lines = null;		if (indexDirectory.indexOf("://")>=0){			lines = MesquiteFile.getURLContentsAsStrings(indexDirectory + "/" + fileName, false);		}		else {			lines = MesquiteFile.getFileContentsAsStrings(indexDirectory + MesquiteFile.fileSeparator + fileName, false);		}		return lines;	}	//TaxaToTerminals.txt	//	 static int TAXONINMATRIXpos = 0; //TaxaToTerminals_TaxonNameInMatrix	//	 static int TAXONINIMAGES = 1; //TaxaToTerminals_ImageTaxonID	/*String[] getImageTaxonNames(String formalTaxon, String formalTaxonID){		String[] matches =  getMatches(formalTaxaToImageTaxa, formalTaxonID, TaxaToTerminals_TaxonUniqueIDInMatrix, TaxaToTerminals_ImageTaxonID);		if (matches == null || matches.length == 0)			return getMatches(formalTaxaToImageTaxa, formalTaxon, TaxaToTerminals_TaxonNameInMatrix, TaxaToTerminals_ImageTaxonID);		return matches;	}	/*-----------------------------------------------------------*/	//ImageData.txt	//	 static int TAXONINIMAGESim = 0; //ImageData_ImageTaxonID	// static int STANDARDVIEWID = 1; //ImageData_MorphologyID	// static int COMMENTpos = 2; //ImageData_Comment	//	 static int PATHTOIMAGE = 4; //ImageData_RelativePath	//	 static int FILENAME = 3;  //ImageData_ImageFileName	/**/	String[] getImagePaths(int imageTaxon, int standardView, String prefix){		if (getNumImageData(imageTaxon, standardView) == 0)			return null;		String[] result = new String[getNumImageData(imageTaxon, standardView)];		for (int i = 0; i< getNumImageData(imageTaxon, standardView); i++){			String imageFileName = null;			String relativePath = null;			String info = getImageData(imageTaxon, standardView, i);			if (!StringUtil.blank(info)){				StringTokenizer t = new StringTokenizer(info, "" + (char)2);				int count = 0;				while (t.hasMoreTokens()){					String tok = t.nextToken();					if (count == IMAGEFILENAME)						imageFileName = tok;					if (count == RELATIVEPATH)						relativePath = tok;					count++;				}				String s = relativePath;				s += pathSeparator(s);				if (prefix != null)					s += prefix;				s += imageFileName;				result[i] = s;			}		}		return result;	}	/*-----------------------------------------------------------*/	String[] getComments(int imageTaxon, int standardView){		if (getNumImageData(imageTaxon, standardView) == 0)			return null;		String[] result = new String[getNumImageData(imageTaxon, standardView)];		for (int i = 0; i< getNumImageData(imageTaxon, standardView); i++){			String comment = null;			String info = getImageData(imageTaxon, standardView, i);			if (!StringUtil.blank(info)){				StringTokenizer t = new StringTokenizer(info, "" + (char)2);				int count = 0;				while (t.hasMoreTokens()){					String tok = t.nextToken();					if (count == COMMENT)						comment = tok;					count++;				}				result[i] = comment;			}		}		return result;	}	/*-----------------------------------------------------------*/	//CharsToMorphology.txt	//static int CHARACTERID = 0; //CharsToMorphology_CharID	//static int STANDARDVIEWIDcm = 1; //CharsToMorphology_MorphologyID	NameReference anr = NameReference.getNameReference("StandardView");	public int[] getStandardViews(String character, int ic){		Object n = data.getAssociatedString(anr, ic);		if (n !=null && !StringUtil.blank((String)n)) {			parser.setString((String)n);			String s;			int count = 0;			parser.setPosition(0);			while ((s = parser.getNextToken()) != null){				if (!s.equals(","))					count++;			}			if (count>0){				int[] st = new int[count];				count = 0;				parser.setPosition(0);				while ((s = parser.getNextToken()) != null){					if (!s.equals(",")){						st[count++] = StringArray.indexOf(standardViewNames, s);					}				}				return st;			}		}		String charID = data.getUniqueID(ic);		int localCharNumber = StringArray.indexOf(indexedCharacterUniqueIDs, charID);  //finding local character number from id		if (localCharNumber>=0)			return standardViewsForIndexedChars[localCharNumber];		return null;	}	public String[] getStandardViewNames(String character, int ic){		Object n = data.getAssociatedString(anr, ic);		if (n !=null && !StringUtil.blank((String)n)) {			parser.setString((String)n);			String s;			int count = 0;			parser.setPosition(0);			while ((s = parser.getNextToken()) != null){				if (!s.equals(","))					count++;			}			if (count>0){				String[] st = new String[count];				count = 0;				parser.setPosition(0);				while ((s = parser.getNextToken()) != null){					if (!s.equals(",")){						st[count++] = s;					}				}				return st;			}		}		String charID = data.getUniqueID(ic);		int localCharNumber = StringArray.indexOf(indexedCharacterUniqueIDs, charID);  //finding local character number from id		if (localCharNumber>=0 && standardViewsForIndexedChars[localCharNumber] != null && standardViewsForIndexedChars[localCharNumber].length >0){			String[] s = new String[standardViewsForIndexedChars[localCharNumber].length];			for (int i = 0; i< s.length; i++)				s[i] = standardViewNames[standardViewsForIndexedChars[localCharNumber][i]];			return s;		}		return null;	}		/*-----------------------------------------------------------*/	String[] toStrings(Vector v){		if (v == null)			return null;		if (v.size()>0){			String[] m = new String[v.size()];			for (int i = 0; i<v.size(); i++){				m[i] = (String)v.elementAt(i);			}			return m;		}		return null;	}	/*-----------------------------------------------------------*/	String prepareTaxonName(String formalTaxon){		//ParseUtil.tokenize(formalTaxon)		return formalTaxon;	}	String[] getPathsForFormalTaxonAndCharacter(String character, int ic, String formalTaxon, String formalTaxonID, String prefix){		int localTaxonNumber = StringArray.indexOf(indexedTaxonUniqueIDs, formalTaxonID);  //finding local taxon number from id		if (localTaxonNumber<0)			localTaxonNumber = StringArray.indexOf(indexedTaxonNames, formalTaxon);  //finding local taxon number from name		if (localTaxonNumber<0)			return null;		int[] imageTaxa = imageTaxaForIndexedTaxa[localTaxonNumber];		int[] standardViews = getStandardViews(character, ic);		if (imageTaxa == null || standardViews == null)			return null;		Vector result = new Vector();		for (int iView = 0; iView<standardViews.length; iView++){			for (int it = 0; it<imageTaxa.length; it++){				String[] matches = getImagePaths(imageTaxa[it], standardViews[iView], prefix);				if (matches != null) {					for (int i=0; i< matches.length; i++)						result.addElement(matches[i]);				}			}		}		return toStrings(result);	}	String[] getCommentsForFormalTaxonAndCharacter(String character, int ic, String formalTaxon, String formalTaxonID){		int localTaxonNumber = StringArray.indexOf(indexedTaxonUniqueIDs, formalTaxonID);  //finding local taxon number from id		if (localTaxonNumber<0)			localTaxonNumber = StringArray.indexOf(indexedTaxonNames, formalTaxon);  //finding local taxon number from name		if (localTaxonNumber<0)			return null;		int[] imageTaxa = imageTaxaForIndexedTaxa[localTaxonNumber];		int[] standardViews = getStandardViews(character, ic);		if (imageTaxa == null || standardViews == null)			return null;		Vector result = new Vector();		for (int iView = 0; iView<standardViews.length; iView++){			for (int it = 0; it<imageTaxa.length; it++){				String[] matches = getComments(imageTaxa[it], standardViews[iView]);				if (matches != null) {					for (int i=0; i< matches.length; i++)						result.addElement(matches[i]);				}			}		}		return toStrings(result);	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	String getNonNull(String[] paths, int whichPath, boolean[] unique){		if (paths == null)			return null;		int count = 0;		for (int i=0; i<paths.length; i++)			if (!StringUtil.blank(paths[i]) && unique[i]) {				if (count == whichPath)					return paths[i];				count++;			}		return null;	}	boolean[] calculateUnique(String[] paths){		if (paths == null)			return null;		boolean[] b = new boolean[paths.length];		for (int i=0; i<b.length; i++){			b[i] = (!isFoundBefore(paths, paths[i], i));		}		return b;	}	boolean isFoundBefore(String[] paths, String target, int p){		if (target == null)			return false;		for (int i=0; i<p; i++)			if (paths[i] != null && target.equals(paths[i]))				return true;		return false;	}	String getPrefix(String pathToImages){		if (pathToImages.endsWith(MesquiteFile.fileSeparator) || pathToImages.endsWith("/")){			pathToImages += "_prefix.txt";		}		else {			pathToImages += pathSeparator(pathToImages) + "_prefix.txt";		}		String s;		if (pathToImages.indexOf("://")<0) //local			s = MesquiteFile.getFileContentsAsString(pathToImages, 500, 100, false);		else			s = MesquiteFile.getURLContentsAsString(pathToImages, 500, false);		if (s == null)			return "";		return parser.getFirstToken(s);	}	/*.................................................................................................................*/	public String getCellImageLocation(int i, CharacterData data, int ic, int it, MesquiteString comment){		if (!ready)			return null;		if (ic < 0)			return null;		this.data = data;		String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";		if (prefixLow == null)			prefixLow = getPrefix(base);		String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it), prefixLow);		boolean[] unique = calculateUnique(paths);		if (i>= getNumberNonNull(paths, unique))			return null;		String path = getNonNull(paths, i, unique);		if (path == null)			return null;		if (path.indexOf("://")<0) {			path = base + pathSeparator(base)  + path;		}		if (path.indexOf("://")>=0){ //should only massage if path is unmassaged			path = StringUtil.encodeForURL(path);		}		String[] comments = getCommentsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it));		String commentt = getNonNull(comments, i, unique);		if (comment!= null)			comment.setValue(commentt);		return path;	}	/*.................................................................................................................*/	public Image getCellImage(int i, CharacterData data, int ic, int it, MesquiteString comment, MesquiteString location){		try {			if (!ready)				return null;			if (ic < 0)				return null;			if (data == null)				return null;			this.data = data;			String base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";			if (prefixLow == null)				prefixLow = getPrefix(base);			String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it), prefixLow);			boolean[] unique = calculateUnique(paths);			if (i>= getNumberNonNull(paths, unique))				return null;			String path = getNonNull(paths, i, unique);			if (path == null)				return null;			if (path.indexOf("://")<0) {				path = base + pathSeparator(base)  + path;				if (MesquiteFile.fileSeparator.equals("/"))					path = StringUtil.replace(path, "\\", "/");				else if (MesquiteFile.fileSeparator.equals("\\"))					path = StringUtil.replace(path, "/", "\\");			}			if (path.indexOf("://")>=0){ //should only massage if path is unmassaged				path = StringUtil.encodeForURL(path);				path = StringUtil.replace(path, "\\", "/");			}			Image image = MesquiteImage.getImage(path, false);			if (image != null)				MesquiteImage.waitForImageToLoad(image);			String[] comments = getCommentsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it));			String commentt = getNonNull(comments, i, unique);			if (comment!= null)				comment.setValue(commentt);			if (location!= null)				location.setValue(path);			return image;		}		catch (Exception e){			MesquiteFile.throwableToLog(this, e);			return null;		}	}	/*.................................................................................................................*/	int getNumberNonNull(String[] paths, boolean[] unique){		if (paths == null)			return 0;		int count = 0;		for (int i=0; i<paths.length; i++)			if (unique[i] && !StringUtil.blank(paths[i]))				count++;		return count;	}	int[][][] numCellImages;	/*.................................................................................................................*/	public int[] getNumCellImages(CharacterData data, int ic, int it){		if (!ready)			return null;		if (ic < 0)			return null;		String[] paths = null;		try {			if (numCellImages == null || numCellImages.length != data.getNumChars() || numCellImages[0].length != data.getNumTaxa()){				numThread.reinitializeNumCellImages();			}			if (numCellImages[ic][it] == null){				paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it), "");				boolean[] unique = calculateUnique(paths);				int num = getNumberNonNull(paths, unique);				int[] nums = new int[ num];				for (int i=0; i<num; i++){					nums[i] =1;				}				numCellImages[ic][it] = nums;				return nums;			}			return numCellImages[ic][it];		}		catch (Exception e){			//MesquiteFile.throwableToLog(this, e);			return null;		}	}	/*.................................................................................................................*/	/** passes which object changed, along with optional integer (e.g. for character) (from MesquiteListener interface)*/	public void changed(Object caller, Object obj, Notification notification){		int code = Notification.getCode(notification);		int[] parameters = Notification.getParameters(notification);		if (obj instanceof CharacterData && (CharacterData)obj ==data) {			if (code==MesquiteListener.NAMES_CHANGED || code==MesquiteListener.SELECTION_CHANGED || code==MesquiteListener.DATA_CHANGED) {			}			else if (code==MesquiteListener.PARTS_DELETED || code==MesquiteListener.PARTS_ADDED || code==MesquiteListener.PARTS_MOVED) {				if (numThread != null)					numThread.reinitializeNumCellImages();			}		}		else if (obj instanceof Taxa && (Taxa)obj ==data.getTaxa()) {			if (code==MesquiteListener.NAMES_CHANGED || code==MesquiteListener.SELECTION_CHANGED || code==MesquiteListener.DATA_CHANGED) {			}			else if (code==MesquiteListener.PARTS_DELETED || code==MesquiteListener.PARTS_ADDED || code==MesquiteListener.PARTS_MOVED) {				if (numThread != null)					numThread.reinitializeNumCellImages();			}		}		super.changed(caller, obj, notification);	}	/*.................................................................................................................*/	public boolean showCloseupCellImage(int i, CharacterData data, int ic, int it, int modifiers){		if (!ready)			return false;		if (ic < 0)			return false;		String prefix = null;		String base;		if (MesquiteEvent.optionKeyDown(modifiers)){			base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";			if (prefixLow == null)				prefixLow = getPrefix(base);			prefix = prefixLow;		}		else {			base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "HighRes";			if (prefixHigh == null)				prefixHigh = getPrefix(base);			prefix = prefixHigh;		}		String viewer = "open";		String[] paths = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it), prefix);		boolean[] unique = calculateUnique(paths);		String imagePath = getNonNull(paths, i, unique);		if (imagePath == null)			return false;		imagePath = base + pathSeparator(base)  + imagePath;		if (imagePath.indexOf("://")<0) {			if (MesquiteFile.fileSeparator.equals("/"))				imagePath = StringUtil.replace(imagePath, "\\", "/");			else if (MesquiteFile.fileSeparator.equals("\\"))				imagePath = StringUtil.replace(imagePath, "/", "\\");			if (!MesquiteFile.fileExists(imagePath)){				logln("HighRes image not found; loading LowRes instead");				base = imageDirectoryBase+ pathSeparator(imageDirectoryBase) + "LowRes";				if (prefixLow == null)					prefixLow = getPrefix(base);				prefix = prefixLow;				String[] pathsL = getPathsForFormalTaxonAndCharacter(data.getUniqueID(ic), ic, prepareTaxonName(data.getTaxa().getTaxonName(it)), data.getTaxa().getUniqueID(it), prefix);				boolean[] uniqueL = calculateUnique(pathsL);				imagePath = getNonNull(pathsL, i, uniqueL);				imagePath = base + pathSeparator(base)  + imagePath;				if (MesquiteFile.fileSeparator.equals("/"))					imagePath = StringUtil.replace(imagePath, "\\", "/");				else if (MesquiteFile.fileSeparator.equals("\\"))					imagePath = StringUtil.replace(imagePath, "/", "\\");			}		}		if (imagePath.indexOf("://")>=0){ //should only massage if path is unmassaged			imagePath = StringUtil.encodeForURL(imagePath);			imagePath = StringUtil.replace(imagePath, "\\", "/");		}		logln("Opening image at " + imagePath);		if (!MesquiteTrunk.isMacOSX()){			viewer = indexManager.getViewer(imagePath);			if (viewer == null)				viewer = "open";			imagePath = "\"" + imagePath + "\"";		}		//String viewer = "C:\\Program Files\\ACD Systems\\ACDSee\\ACDSee.exe";		//String imagePath = "\"" + imageDirectoryBase + MesquiteFile.fileSeparator + getNonNull(paths, i) + "\"";		try {			Process p = Runtime.getRuntime().exec(new String[]{ viewer, imagePath});			return true;		}		catch (IOException e){			MesquiteMessage.println("exception in showCloseupCellImage ");			MesquiteFile.throwableToLog(this, e);		}		return false;	}	/*.................................................................................................................*/	public String getName() {		return "Indexed Cell Matrix Images";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Gives images for a matrix from indexed storage." ;	}}class NumCellImagesThread extends Thread {	IndexedCellImages module;	CharacterData data;	int status = 0;	public NumCellImagesThread(IndexedCellImages module, CharacterData data){		this.module = module;		this.data = data;		setPriority(MIN_PRIORITY);	}	void reinitializeNumCellImages(){		module.numCellImages = new int[data.getNumChars()][data.getNumTaxa()][];		setStatus(2);	}	void stopThread(){		setStatus(-1);	}	void setStatus(int i){		status = i;	}	public void run(){		try {			if (data != null){				while (status>=0){					if (status == 0){ // just starting or reinitialized						module.numCellImages = new int[data.getNumChars()][data.getNumTaxa()][];						setStatus(2);					}					if (status == 1) //done; doing nothing						Thread.sleep(50);					else if (status == 2){ //continue calculation						Thread.sleep(20);						if (module.ready){							try {								for (int ic = 0; ic < data.getNumChars() && status ==2; ic++){									for (int it = 0; it < data.getNumTaxa() && status ==2; it++) {										if (module.numCellImages[ic][it] == null)											module.numCellImages[ic][it] = module.getNumCellImages(data, ic, it);									}								}								setStatus(1);								module.logln("Numbers of cell images cached");							}							catch (Exception e){							}						}					}				}			}		}		catch (InterruptedException e){		}	}}